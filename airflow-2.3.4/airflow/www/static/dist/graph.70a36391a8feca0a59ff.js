/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Airflow"] = factory();
	else
		root["Airflow"] = root["Airflow"] || {}, root["Airflow"]["graph"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./static/js/dag.js":
/*!**************************!*\
  !*** ./static/js/dag.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"callModal\": () => (/* binding */ callModal),\n/* harmony export */   \"dagTZ\": () => (/* binding */ dagTZ)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./static/js/utils.js\");\n/* harmony import */ var _datetime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datetime_utils */ \"./static/js/datetime_utils.js\");\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* global document, window, CustomEvent, $ */\n\n\n\nfunction updateQueryStringParameter(uri, key, value) {\n  const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n  const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n\n  if (uri.match(re)) {\n    return uri.replace(re, `$1${key}=${value}$2`);\n  }\n\n  return `${uri}${separator}${key}=${value}`;\n} // Pills highlighting\n\n\n$(window).on('load', function onLoad() {\n  $(`a[href*=\"${this.location.pathname}\"]`).parent().addClass('active');\n  $('.never_active').removeClass('active');\n});\nconst dagId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('dag_id');\nconst dagTZ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('dag_timezone');\nconst logsWithMetadataUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('logs_with_metadata_url');\nconst externalLogUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('external_log_url');\nconst extraLinksUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('extra_links_url');\nconst pausedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('paused_url');\nconst nextRun = {\n  createAfter: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('next_dagrun_create_after'),\n  intervalStart: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('next_dagrun_data_interval_start'),\n  intervalEnd: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('next_dagrun_data_interval_end')\n};\nlet taskId = '';\nlet executionDate = '';\nlet subdagId = '';\nlet dagRunId = '';\nlet mapIndex;\nlet mapStates = [];\nconst showExternalLogRedirect = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('show_external_log_redirect') === 'True';\nconst buttons = Array.from(document.querySelectorAll('a[id^=\"btn_\"][data-base-url]')).reduce((obj, elm) => {\n  obj[elm.id.replace('btn_', '')] = elm;\n  return obj;\n}, {});\n\nfunction updateButtonUrl(elm, params) {\n  let url = elm.dataset.baseUrl;\n\n  if (params.dag_id && elm.dataset.baseUrl.indexOf(dagId) !== -1) {\n    url = url.replace(dagId, params.dag_id);\n    delete params.dag_id;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(params, 'map_index') && params.map_index === undefined) {\n    delete params.map_index;\n  }\n\n  elm.setAttribute('href', `${url}?${$.param(params)}`);\n}\n\nfunction updateModalUrls() {\n  updateButtonUrl(buttons.subdag, {\n    dag_id: subdagId,\n    execution_date: executionDate\n  });\n  updateButtonUrl(buttons.task, {\n    dag_id: dagId,\n    task_id: taskId,\n    execution_date: executionDate,\n    map_index: mapIndex\n  });\n  updateButtonUrl(buttons.rendered, {\n    dag_id: dagId,\n    task_id: taskId,\n    execution_date: executionDate,\n    map_index: mapIndex\n  });\n  updateButtonUrl(buttons.mapped, {\n    _flt_3_dag_id: dagId,\n    _flt_3_task_id: taskId,\n    _flt_3_run_id: dagRunId,\n    _oc_TaskInstanceModelView: 'map_index'\n  });\n\n  if (buttons.rendered_k8s) {\n    updateButtonUrl(buttons.rendered_k8s, {\n      dag_id: dagId,\n      task_id: taskId,\n      execution_date: executionDate,\n      map_index: mapIndex\n    });\n  }\n\n  const tiButtonParams = {\n    _flt_3_dag_id: dagId,\n    _flt_3_task_id: taskId,\n    _oc_TaskInstanceModelView: 'dag_run.execution_date'\n  }; // eslint-disable-next-line no-underscore-dangle\n\n  if (mapIndex >= 0) tiButtonParams._flt_0_map_index = mapIndex;\n  updateButtonUrl(buttons.ti, tiButtonParams);\n  updateButtonUrl(buttons.log, {\n    dag_id: dagId,\n    task_id: taskId,\n    execution_date: executionDate,\n    map_index: mapIndex\n  });\n  updateButtonUrl(buttons.xcom, {\n    dag_id: dagId,\n    task_id: taskId,\n    execution_date: executionDate,\n    map_index: mapIndex\n  });\n} // Update modal urls on toggle\n\n\ndocument.addEventListener('click', event => {\n  if (event.target.matches('button[data-toggle=\"button\"]')) {\n    updateModalUrls();\n  }\n});\nfunction callModal({\n  taskId: t,\n  executionDate: d,\n  extraLinks,\n  tryNumber,\n  isSubDag,\n  dagRunId: drID,\n  mapIndex: mi,\n  isMapped = false,\n  mappedStates = []\n}) {\n  taskId = t;\n  const location = String(window.location);\n  $('#btn_filter').on('click', () => {\n    window.location = updateQueryStringParameter(location, 'root', taskId);\n  });\n  executionDate = d;\n  dagRunId = drID;\n  mapIndex = mi;\n\n  if (isMapped) {\n    mapStates = mappedStates;\n  }\n\n  $('#dag_run_id').text(drID);\n  $('#task_id').text(t);\n  $('#execution_date').text((0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(d));\n  $('#taskInstanceModal').modal({});\n  $('#taskInstanceModal').css('margin-top', '0');\n  $('#extra_links').prev('hr').hide();\n  $('#extra_links').empty().hide();\n\n  if (mi >= 0) {\n    $('#modal_map_index').show();\n    $('#modal_map_index .value').text(mi);\n  } else {\n    $('#modal_map_index').hide();\n    $('#modal_map_index .value').text('');\n  }\n\n  if (isSubDag) {\n    $('#div_btn_subdag').show();\n    subdagId = `${dagId}.${t}`;\n  } else {\n    $('#div_btn_subdag').hide();\n    subdagId = undefined;\n  } // Show a span or dropdown for mapIndex\n\n\n  if (mi >= 0 && !mapStates.length) {\n    $('#modal_map_index').show();\n    $('#modal_map_index .value').text(mi);\n    $('#mapped_dropdown').hide();\n  } else if (mi >= 0 || isMapped) {\n    $('#modal_map_index').show();\n    $('#modal_map_index .value').text('');\n    $('#mapped_dropdown').show();\n    const dropdownText = mapIndex > -1 ? mapIndex : `All  ${mapStates.length} Mapped Instances`;\n    $('#mapped_dropdown #dropdown-label').text(dropdownText);\n    $('#mapped_dropdown .dropdown-menu').empty();\n    $('#mapped_dropdown .dropdown-menu').append(`<li><a href=\"#\" class=\"map_index_item\" data-mapIndex=\"all\">All ${mapStates.length} Mapped Instances</a></li>`);\n    mapStates.forEach((state, i) => {\n      $('#mapped_dropdown .dropdown-menu').append(`<li><a href=\"#\" class=\"map_index_item\" data-mapIndex=\"${i}\">${i} - ${state}</a></li>`);\n    });\n  } else {\n    $('#modal_map_index').hide();\n    $('#modal_map_index .value').text('');\n    $('#mapped_dropdown').hide();\n  }\n\n  if (isMapped) {\n    $('#task_actions').text(`Task Actions for all ${mappedStates.length} instances`);\n    $('#btn_mapped').show();\n    $('#mapped_dropdown').css('display', 'inline-block');\n    $('#btn_rendered').hide();\n    $('#btn_xcom').hide();\n    $('#btn_log').hide();\n    $('#btn_task').hide();\n  } else {\n    $('#task_actions').text('Task Actions');\n    $('#btn_rendered').show();\n    $('#btn_xcom').show();\n    $('#btn_log').show();\n    $('#btn_mapped').hide();\n    $('#btn_task').show();\n  }\n\n  $('#dag_dl_logs').hide();\n  $('#dag_redir_logs').hide();\n\n  if (tryNumber > 0 && !isMapped) {\n    $('#dag_dl_logs').show();\n\n    if (showExternalLogRedirect) {\n      $('#dag_redir_logs').show();\n    }\n  }\n\n  updateModalUrls();\n  $('#try_index > li').remove();\n  $('#redir_log_try_index > li').remove();\n  const startIndex = tryNumber > 2 ? 0 : 1;\n  const query = new URLSearchParams({\n    dag_id: dagId,\n    task_id: taskId,\n    execution_date: executionDate,\n    metadata: 'null'\n  });\n\n  if (mi !== undefined) {\n    query.set('map_index', mi);\n  }\n\n  for (let index = startIndex; index < tryNumber; index += 1) {\n    let showLabel = index;\n\n    if (index !== 0) {\n      query.set('try_number', index);\n    } else {\n      showLabel = 'All';\n    }\n\n    $('#try_index').append(`<li role=\"presentation\" style=\"display:inline\">\n      <a href=\"${logsWithMetadataUrl}?${query}&format=file\"> ${showLabel} </a>\n      </li>`);\n\n    if (index !== 0 || showExternalLogRedirect) {\n      $('#redir_log_try_index').append(`<li role=\"presentation\" style=\"display:inline\">\n      <a href=\"${externalLogUrl}?${query}\"> ${showLabel} </a>\n      </li>`);\n    }\n  }\n\n  query.delete('try_number');\n\n  if (extraLinks && extraLinks.length > 0) {\n    const markupArr = [];\n    extraLinks.sort();\n    $.each(extraLinks, (i, link) => {\n      query.set('link_name', link);\n      const externalLink = $('<a href=\"#\" class=\"btn btn-primary disabled\"></a>');\n      const linkTooltip = $('<span class=\"tool-tip\" data-toggle=\"tooltip\" style=\"padding-right: 2px; padding-left: 3px\" data-placement=\"top\" ' + 'title=\"link not yet available\"></span>');\n      linkTooltip.append(externalLink);\n      externalLink.text(link);\n      $.ajax({\n        url: `${extraLinksUrl}?${query}`,\n        cache: false,\n\n        success(data) {\n          externalLink.attr('href', data.url); // open absolute (external) links in a new tab/window and relative (local) links\n          // directly\n\n          if (/^(?:[a-z]+:)?\\/\\//.test(data.url)) {\n            externalLink.attr('target', '_blank');\n          }\n\n          externalLink.removeClass('disabled');\n          linkTooltip.tooltip('disable');\n        },\n\n        error(data) {\n          linkTooltip.tooltip('hide').attr('title', data.responseJSON.error).tooltip('fixTitle');\n        }\n\n      });\n      markupArr.push(linkTooltip);\n    });\n    const extraLinksSpan = $('#extra_links');\n    extraLinksSpan.prev('hr').show();\n    extraLinksSpan.append(markupArr).show();\n    extraLinksSpan.find('[data-toggle=\"tooltip\"]').tooltip();\n  }\n} // Switch the modal from a mapped task summary to a specific mapped task instance\n\n$(document).on('click', '.map_index_item', function mapItem() {\n  const mi = $(this).attr('data-mapIndex');\n\n  if (mi === 'all') {\n    callModal({\n      taskId,\n      executionDate,\n      dagRunId,\n      mapIndex: -1,\n      isMapped: true,\n      mappedStates: mapStates\n    });\n  } else {\n    callModal({\n      taskId,\n      executionDate,\n      dagRunId,\n      mapIndex: mi\n    });\n  }\n}); // Task Instance Modal actions\n\n$('form[data-action]').on('submit', function submit(e) {\n  e.preventDefault();\n  const form = $(this).get(0);\n\n  if (dagRunId || executionDate) {\n    if (form.dag_run_id) {\n      form.dag_run_id.value = dagRunId;\n    }\n\n    if (form.execution_date) {\n      form.execution_date.value = executionDate;\n    }\n\n    form.origin.value = window.location;\n\n    if (form.task_id) {\n      form.task_id.value = taskId;\n    }\n\n    if (form.map_index && mapIndex >= 0) {\n      form.map_index.value = mapIndex;\n    } else if (form.map_index) {\n      form.map_index.remove();\n    }\n\n    form.action = $(this).data('action');\n    form.submit();\n  }\n});\n$('#pause_resume').on('change', function onChange() {\n  const $input = $(this);\n  const id = $input.data('dag-id');\n  const isPaused = $input.is(':checked');\n  const url = `${pausedUrl}?is_paused=${isPaused}&dag_id=${encodeURIComponent(id)}`; // Remove focus on element so the tooltip will go away\n\n  $input.trigger('blur');\n  $input.removeClass('switch-input--error'); // dispatch an event that React can listen for\n\n  const event = new CustomEvent('paused', {\n    detail: isPaused\n  });\n  document.dispatchEvent(event);\n  $.post(url).fail(() => {\n    setTimeout(() => {\n      $input.prop('checked', !isPaused);\n      $input.addClass('switch-input--error');\n      event.value = !isPaused;\n      document.dispatchEvent(event);\n    }, 500);\n  });\n});\n$('#next-run').on('mouseover', () => {\n  $('#next-run').attr('data-original-title', () => {\n    let newTitle = '';\n\n    if (nextRun.createAfter) {\n      newTitle += `<strong>Run After:</strong> ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(nextRun.createAfter)}<br>`;\n      newTitle += `Next Run: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.approxTimeFromNow)(nextRun.createAfter)}<br><br>`;\n    }\n\n    if (nextRun.intervalStart && nextRun.intervalEnd) {\n      newTitle += '<strong>Data Interval</strong><br>';\n      newTitle += `Start: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(nextRun.intervalStart)}<br>`;\n      newTitle += `End: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(nextRun.intervalEnd)}`;\n    }\n\n    return newTitle;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvZGFnLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0FpcmZsb3cvLi9zdGF0aWMvanMvZGFnLmpzPzA3NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgQ3VzdG9tRXZlbnQsICQgKi9cbmltcG9ydCB7IGdldE1ldGFWYWx1ZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgYXBwcm94VGltZUZyb21Ob3csIGZvcm1hdERhdGVUaW1lIH0gZnJvbSAnLi9kYXRldGltZV91dGlscyc7XG5cbmZ1bmN0aW9uIHVwZGF0ZVF1ZXJ5U3RyaW5nUGFyYW1ldGVyKHVyaSwga2V5LCB2YWx1ZSkge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYChbPyZdKSR7a2V5fT0uKj8oJnwkKWAsICdpJyk7XG4gIGNvbnN0IHNlcGFyYXRvciA9IHVyaS5pbmRleE9mKCc/JykgIT09IC0xID8gJyYnIDogJz8nO1xuXG4gIGlmICh1cmkubWF0Y2gocmUpKSB7XG4gICAgcmV0dXJuIHVyaS5yZXBsYWNlKHJlLCBgJDEke2tleX09JHt2YWx1ZX0kMmApO1xuICB9XG5cbiAgcmV0dXJuIGAke3VyaX0ke3NlcGFyYXRvcn0ke2tleX09JHt2YWx1ZX1gO1xufSAvLyBQaWxscyBoaWdobGlnaHRpbmdcblxuXG4kKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICQoYGFbaHJlZio9XCIke3RoaXMubG9jYXRpb24ucGF0aG5hbWV9XCJdYCkucGFyZW50KCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAkKCcubmV2ZXJfYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xufSk7XG5jb25zdCBkYWdJZCA9IGdldE1ldGFWYWx1ZSgnZGFnX2lkJyk7XG5leHBvcnQgY29uc3QgZGFnVFogPSBnZXRNZXRhVmFsdWUoJ2RhZ190aW1lem9uZScpO1xuY29uc3QgbG9nc1dpdGhNZXRhZGF0YVVybCA9IGdldE1ldGFWYWx1ZSgnbG9nc193aXRoX21ldGFkYXRhX3VybCcpO1xuY29uc3QgZXh0ZXJuYWxMb2dVcmwgPSBnZXRNZXRhVmFsdWUoJ2V4dGVybmFsX2xvZ191cmwnKTtcbmNvbnN0IGV4dHJhTGlua3NVcmwgPSBnZXRNZXRhVmFsdWUoJ2V4dHJhX2xpbmtzX3VybCcpO1xuY29uc3QgcGF1c2VkVXJsID0gZ2V0TWV0YVZhbHVlKCdwYXVzZWRfdXJsJyk7XG5jb25zdCBuZXh0UnVuID0ge1xuICBjcmVhdGVBZnRlcjogZ2V0TWV0YVZhbHVlKCduZXh0X2RhZ3J1bl9jcmVhdGVfYWZ0ZXInKSxcbiAgaW50ZXJ2YWxTdGFydDogZ2V0TWV0YVZhbHVlKCduZXh0X2RhZ3J1bl9kYXRhX2ludGVydmFsX3N0YXJ0JyksXG4gIGludGVydmFsRW5kOiBnZXRNZXRhVmFsdWUoJ25leHRfZGFncnVuX2RhdGFfaW50ZXJ2YWxfZW5kJylcbn07XG5sZXQgdGFza0lkID0gJyc7XG5sZXQgZXhlY3V0aW9uRGF0ZSA9ICcnO1xubGV0IHN1YmRhZ0lkID0gJyc7XG5sZXQgZGFnUnVuSWQgPSAnJztcbmxldCBtYXBJbmRleDtcbmxldCBtYXBTdGF0ZXMgPSBbXTtcbmNvbnN0IHNob3dFeHRlcm5hbExvZ1JlZGlyZWN0ID0gZ2V0TWV0YVZhbHVlKCdzaG93X2V4dGVybmFsX2xvZ19yZWRpcmVjdCcpID09PSAnVHJ1ZSc7XG5jb25zdCBidXR0b25zID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2lkXj1cImJ0bl9cIl1bZGF0YS1iYXNlLXVybF0nKSkucmVkdWNlKChvYmosIGVsbSkgPT4ge1xuICBvYmpbZWxtLmlkLnJlcGxhY2UoJ2J0bl8nLCAnJyldID0gZWxtO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG5mdW5jdGlvbiB1cGRhdGVCdXR0b25VcmwoZWxtLCBwYXJhbXMpIHtcbiAgbGV0IHVybCA9IGVsbS5kYXRhc2V0LmJhc2VVcmw7XG5cbiAgaWYgKHBhcmFtcy5kYWdfaWQgJiYgZWxtLmRhdGFzZXQuYmFzZVVybC5pbmRleE9mKGRhZ0lkKSAhPT0gLTEpIHtcbiAgICB1cmwgPSB1cmwucmVwbGFjZShkYWdJZCwgcGFyYW1zLmRhZ19pZCk7XG4gICAgZGVsZXRlIHBhcmFtcy5kYWdfaWQ7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ21hcF9pbmRleCcpICYmIHBhcmFtcy5tYXBfaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBwYXJhbXMubWFwX2luZGV4O1xuICB9XG5cbiAgZWxtLnNldEF0dHJpYnV0ZSgnaHJlZicsIGAke3VybH0/JHskLnBhcmFtKHBhcmFtcyl9YCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGFsVXJscygpIHtcbiAgdXBkYXRlQnV0dG9uVXJsKGJ1dHRvbnMuc3ViZGFnLCB7XG4gICAgZGFnX2lkOiBzdWJkYWdJZCxcbiAgICBleGVjdXRpb25fZGF0ZTogZXhlY3V0aW9uRGF0ZVxuICB9KTtcbiAgdXBkYXRlQnV0dG9uVXJsKGJ1dHRvbnMudGFzaywge1xuICAgIGRhZ19pZDogZGFnSWQsXG4gICAgdGFza19pZDogdGFza0lkLFxuICAgIGV4ZWN1dGlvbl9kYXRlOiBleGVjdXRpb25EYXRlLFxuICAgIG1hcF9pbmRleDogbWFwSW5kZXhcbiAgfSk7XG4gIHVwZGF0ZUJ1dHRvblVybChidXR0b25zLnJlbmRlcmVkLCB7XG4gICAgZGFnX2lkOiBkYWdJZCxcbiAgICB0YXNrX2lkOiB0YXNrSWQsXG4gICAgZXhlY3V0aW9uX2RhdGU6IGV4ZWN1dGlvbkRhdGUsXG4gICAgbWFwX2luZGV4OiBtYXBJbmRleFxuICB9KTtcbiAgdXBkYXRlQnV0dG9uVXJsKGJ1dHRvbnMubWFwcGVkLCB7XG4gICAgX2ZsdF8zX2RhZ19pZDogZGFnSWQsXG4gICAgX2ZsdF8zX3Rhc2tfaWQ6IHRhc2tJZCxcbiAgICBfZmx0XzNfcnVuX2lkOiBkYWdSdW5JZCxcbiAgICBfb2NfVGFza0luc3RhbmNlTW9kZWxWaWV3OiAnbWFwX2luZGV4J1xuICB9KTtcblxuICBpZiAoYnV0dG9ucy5yZW5kZXJlZF9rOHMpIHtcbiAgICB1cGRhdGVCdXR0b25VcmwoYnV0dG9ucy5yZW5kZXJlZF9rOHMsIHtcbiAgICAgIGRhZ19pZDogZGFnSWQsXG4gICAgICB0YXNrX2lkOiB0YXNrSWQsXG4gICAgICBleGVjdXRpb25fZGF0ZTogZXhlY3V0aW9uRGF0ZSxcbiAgICAgIG1hcF9pbmRleDogbWFwSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHRpQnV0dG9uUGFyYW1zID0ge1xuICAgIF9mbHRfM19kYWdfaWQ6IGRhZ0lkLFxuICAgIF9mbHRfM190YXNrX2lkOiB0YXNrSWQsXG4gICAgX29jX1Rhc2tJbnN0YW5jZU1vZGVsVmlldzogJ2RhZ19ydW4uZXhlY3V0aW9uX2RhdGUnXG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuXG4gIGlmIChtYXBJbmRleCA+PSAwKSB0aUJ1dHRvblBhcmFtcy5fZmx0XzBfbWFwX2luZGV4ID0gbWFwSW5kZXg7XG4gIHVwZGF0ZUJ1dHRvblVybChidXR0b25zLnRpLCB0aUJ1dHRvblBhcmFtcyk7XG4gIHVwZGF0ZUJ1dHRvblVybChidXR0b25zLmxvZywge1xuICAgIGRhZ19pZDogZGFnSWQsXG4gICAgdGFza19pZDogdGFza0lkLFxuICAgIGV4ZWN1dGlvbl9kYXRlOiBleGVjdXRpb25EYXRlLFxuICAgIG1hcF9pbmRleDogbWFwSW5kZXhcbiAgfSk7XG4gIHVwZGF0ZUJ1dHRvblVybChidXR0b25zLnhjb20sIHtcbiAgICBkYWdfaWQ6IGRhZ0lkLFxuICAgIHRhc2tfaWQ6IHRhc2tJZCxcbiAgICBleGVjdXRpb25fZGF0ZTogZXhlY3V0aW9uRGF0ZSxcbiAgICBtYXBfaW5kZXg6IG1hcEluZGV4XG4gIH0pO1xufSAvLyBVcGRhdGUgbW9kYWwgdXJscyBvbiB0b2dnbGVcblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgaWYgKGV2ZW50LnRhcmdldC5tYXRjaGVzKCdidXR0b25bZGF0YS10b2dnbGU9XCJidXR0b25cIl0nKSkge1xuICAgIHVwZGF0ZU1vZGFsVXJscygpO1xuICB9XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjYWxsTW9kYWwoe1xuICB0YXNrSWQ6IHQsXG4gIGV4ZWN1dGlvbkRhdGU6IGQsXG4gIGV4dHJhTGlua3MsXG4gIHRyeU51bWJlcixcbiAgaXNTdWJEYWcsXG4gIGRhZ1J1bklkOiBkcklELFxuICBtYXBJbmRleDogbWksXG4gIGlzTWFwcGVkID0gZmFsc2UsXG4gIG1hcHBlZFN0YXRlcyA9IFtdXG59KSB7XG4gIHRhc2tJZCA9IHQ7XG4gIGNvbnN0IGxvY2F0aW9uID0gU3RyaW5nKHdpbmRvdy5sb2NhdGlvbik7XG4gICQoJyNidG5fZmlsdGVyJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHVwZGF0ZVF1ZXJ5U3RyaW5nUGFyYW1ldGVyKGxvY2F0aW9uLCAncm9vdCcsIHRhc2tJZCk7XG4gIH0pO1xuICBleGVjdXRpb25EYXRlID0gZDtcbiAgZGFnUnVuSWQgPSBkcklEO1xuICBtYXBJbmRleCA9IG1pO1xuXG4gIGlmIChpc01hcHBlZCkge1xuICAgIG1hcFN0YXRlcyA9IG1hcHBlZFN0YXRlcztcbiAgfVxuXG4gICQoJyNkYWdfcnVuX2lkJykudGV4dChkcklEKTtcbiAgJCgnI3Rhc2tfaWQnKS50ZXh0KHQpO1xuICAkKCcjZXhlY3V0aW9uX2RhdGUnKS50ZXh0KGZvcm1hdERhdGVUaW1lKGQpKTtcbiAgJCgnI3Rhc2tJbnN0YW5jZU1vZGFsJykubW9kYWwoe30pO1xuICAkKCcjdGFza0luc3RhbmNlTW9kYWwnKS5jc3MoJ21hcmdpbi10b3AnLCAnMCcpO1xuICAkKCcjZXh0cmFfbGlua3MnKS5wcmV2KCdocicpLmhpZGUoKTtcbiAgJCgnI2V4dHJhX2xpbmtzJykuZW1wdHkoKS5oaWRlKCk7XG5cbiAgaWYgKG1pID49IDApIHtcbiAgICAkKCcjbW9kYWxfbWFwX2luZGV4Jykuc2hvdygpO1xuICAgICQoJyNtb2RhbF9tYXBfaW5kZXggLnZhbHVlJykudGV4dChtaSk7XG4gIH0gZWxzZSB7XG4gICAgJCgnI21vZGFsX21hcF9pbmRleCcpLmhpZGUoKTtcbiAgICAkKCcjbW9kYWxfbWFwX2luZGV4IC52YWx1ZScpLnRleHQoJycpO1xuICB9XG5cbiAgaWYgKGlzU3ViRGFnKSB7XG4gICAgJCgnI2Rpdl9idG5fc3ViZGFnJykuc2hvdygpO1xuICAgIHN1YmRhZ0lkID0gYCR7ZGFnSWR9LiR7dH1gO1xuICB9IGVsc2Uge1xuICAgICQoJyNkaXZfYnRuX3N1YmRhZycpLmhpZGUoKTtcbiAgICBzdWJkYWdJZCA9IHVuZGVmaW5lZDtcbiAgfSAvLyBTaG93IGEgc3BhbiBvciBkcm9wZG93biBmb3IgbWFwSW5kZXhcblxuXG4gIGlmIChtaSA+PSAwICYmICFtYXBTdGF0ZXMubGVuZ3RoKSB7XG4gICAgJCgnI21vZGFsX21hcF9pbmRleCcpLnNob3coKTtcbiAgICAkKCcjbW9kYWxfbWFwX2luZGV4IC52YWx1ZScpLnRleHQobWkpO1xuICAgICQoJyNtYXBwZWRfZHJvcGRvd24nKS5oaWRlKCk7XG4gIH0gZWxzZSBpZiAobWkgPj0gMCB8fCBpc01hcHBlZCkge1xuICAgICQoJyNtb2RhbF9tYXBfaW5kZXgnKS5zaG93KCk7XG4gICAgJCgnI21vZGFsX21hcF9pbmRleCAudmFsdWUnKS50ZXh0KCcnKTtcbiAgICAkKCcjbWFwcGVkX2Ryb3Bkb3duJykuc2hvdygpO1xuICAgIGNvbnN0IGRyb3Bkb3duVGV4dCA9IG1hcEluZGV4ID4gLTEgPyBtYXBJbmRleCA6IGBBbGwgICR7bWFwU3RhdGVzLmxlbmd0aH0gTWFwcGVkIEluc3RhbmNlc2A7XG4gICAgJCgnI21hcHBlZF9kcm9wZG93biAjZHJvcGRvd24tbGFiZWwnKS50ZXh0KGRyb3Bkb3duVGV4dCk7XG4gICAgJCgnI21hcHBlZF9kcm9wZG93biAuZHJvcGRvd24tbWVudScpLmVtcHR5KCk7XG4gICAgJCgnI21hcHBlZF9kcm9wZG93biAuZHJvcGRvd24tbWVudScpLmFwcGVuZChgPGxpPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJtYXBfaW5kZXhfaXRlbVwiIGRhdGEtbWFwSW5kZXg9XCJhbGxcIj5BbGwgJHttYXBTdGF0ZXMubGVuZ3RofSBNYXBwZWQgSW5zdGFuY2VzPC9hPjwvbGk+YCk7XG4gICAgbWFwU3RhdGVzLmZvckVhY2goKHN0YXRlLCBpKSA9PiB7XG4gICAgICAkKCcjbWFwcGVkX2Ryb3Bkb3duIC5kcm9wZG93bi1tZW51JykuYXBwZW5kKGA8bGk+PGEgaHJlZj1cIiNcIiBjbGFzcz1cIm1hcF9pbmRleF9pdGVtXCIgZGF0YS1tYXBJbmRleD1cIiR7aX1cIj4ke2l9IC0gJHtzdGF0ZX08L2E+PC9saT5gKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAkKCcjbW9kYWxfbWFwX2luZGV4JykuaGlkZSgpO1xuICAgICQoJyNtb2RhbF9tYXBfaW5kZXggLnZhbHVlJykudGV4dCgnJyk7XG4gICAgJCgnI21hcHBlZF9kcm9wZG93bicpLmhpZGUoKTtcbiAgfVxuXG4gIGlmIChpc01hcHBlZCkge1xuICAgICQoJyN0YXNrX2FjdGlvbnMnKS50ZXh0KGBUYXNrIEFjdGlvbnMgZm9yIGFsbCAke21hcHBlZFN0YXRlcy5sZW5ndGh9IGluc3RhbmNlc2ApO1xuICAgICQoJyNidG5fbWFwcGVkJykuc2hvdygpO1xuICAgICQoJyNtYXBwZWRfZHJvcGRvd24nKS5jc3MoJ2Rpc3BsYXknLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgJCgnI2J0bl9yZW5kZXJlZCcpLmhpZGUoKTtcbiAgICAkKCcjYnRuX3hjb20nKS5oaWRlKCk7XG4gICAgJCgnI2J0bl9sb2cnKS5oaWRlKCk7XG4gICAgJCgnI2J0bl90YXNrJykuaGlkZSgpO1xuICB9IGVsc2Uge1xuICAgICQoJyN0YXNrX2FjdGlvbnMnKS50ZXh0KCdUYXNrIEFjdGlvbnMnKTtcbiAgICAkKCcjYnRuX3JlbmRlcmVkJykuc2hvdygpO1xuICAgICQoJyNidG5feGNvbScpLnNob3coKTtcbiAgICAkKCcjYnRuX2xvZycpLnNob3coKTtcbiAgICAkKCcjYnRuX21hcHBlZCcpLmhpZGUoKTtcbiAgICAkKCcjYnRuX3Rhc2snKS5zaG93KCk7XG4gIH1cblxuICAkKCcjZGFnX2RsX2xvZ3MnKS5oaWRlKCk7XG4gICQoJyNkYWdfcmVkaXJfbG9ncycpLmhpZGUoKTtcblxuICBpZiAodHJ5TnVtYmVyID4gMCAmJiAhaXNNYXBwZWQpIHtcbiAgICAkKCcjZGFnX2RsX2xvZ3MnKS5zaG93KCk7XG5cbiAgICBpZiAoc2hvd0V4dGVybmFsTG9nUmVkaXJlY3QpIHtcbiAgICAgICQoJyNkYWdfcmVkaXJfbG9ncycpLnNob3coKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNb2RhbFVybHMoKTtcbiAgJCgnI3RyeV9pbmRleCA+IGxpJykucmVtb3ZlKCk7XG4gICQoJyNyZWRpcl9sb2dfdHJ5X2luZGV4ID4gbGknKS5yZW1vdmUoKTtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IHRyeU51bWJlciA+IDIgPyAwIDogMTtcbiAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBkYWdfaWQ6IGRhZ0lkLFxuICAgIHRhc2tfaWQ6IHRhc2tJZCxcbiAgICBleGVjdXRpb25fZGF0ZTogZXhlY3V0aW9uRGF0ZSxcbiAgICBtZXRhZGF0YTogJ251bGwnXG4gIH0pO1xuXG4gIGlmIChtaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcXVlcnkuc2V0KCdtYXBfaW5kZXgnLCBtaSk7XG4gIH1cblxuICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgdHJ5TnVtYmVyOyBpbmRleCArPSAxKSB7XG4gICAgbGV0IHNob3dMYWJlbCA9IGluZGV4O1xuXG4gICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICBxdWVyeS5zZXQoJ3RyeV9udW1iZXInLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dMYWJlbCA9ICdBbGwnO1xuICAgIH1cblxuICAgICQoJyN0cnlfaW5kZXgnKS5hcHBlbmQoYDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZVwiPlxuICAgICAgPGEgaHJlZj1cIiR7bG9nc1dpdGhNZXRhZGF0YVVybH0/JHtxdWVyeX0mZm9ybWF0PWZpbGVcIj4gJHtzaG93TGFiZWx9IDwvYT5cbiAgICAgIDwvbGk+YCk7XG5cbiAgICBpZiAoaW5kZXggIT09IDAgfHwgc2hvd0V4dGVybmFsTG9nUmVkaXJlY3QpIHtcbiAgICAgICQoJyNyZWRpcl9sb2dfdHJ5X2luZGV4JykuYXBwZW5kKGA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiIHN0eWxlPVwiZGlzcGxheTppbmxpbmVcIj5cbiAgICAgIDxhIGhyZWY9XCIke2V4dGVybmFsTG9nVXJsfT8ke3F1ZXJ5fVwiPiAke3Nob3dMYWJlbH0gPC9hPlxuICAgICAgPC9saT5gKTtcbiAgICB9XG4gIH1cblxuICBxdWVyeS5kZWxldGUoJ3RyeV9udW1iZXInKTtcblxuICBpZiAoZXh0cmFMaW5rcyAmJiBleHRyYUxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBtYXJrdXBBcnIgPSBbXTtcbiAgICBleHRyYUxpbmtzLnNvcnQoKTtcbiAgICAkLmVhY2goZXh0cmFMaW5rcywgKGksIGxpbmspID0+IHtcbiAgICAgIHF1ZXJ5LnNldCgnbGlua19uYW1lJywgbGluayk7XG4gICAgICBjb25zdCBleHRlcm5hbExpbmsgPSAkKCc8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGRpc2FibGVkXCI+PC9hPicpO1xuICAgICAgY29uc3QgbGlua1Rvb2x0aXAgPSAkKCc8c3BhbiBjbGFzcz1cInRvb2wtdGlwXCIgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OiAycHg7IHBhZGRpbmctbGVmdDogM3B4XCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiAnICsgJ3RpdGxlPVwibGluayBub3QgeWV0IGF2YWlsYWJsZVwiPjwvc3Bhbj4nKTtcbiAgICAgIGxpbmtUb29sdGlwLmFwcGVuZChleHRlcm5hbExpbmspO1xuICAgICAgZXh0ZXJuYWxMaW5rLnRleHQobGluayk7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6IGAke2V4dHJhTGlua3NVcmx9PyR7cXVlcnl9YCxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuXG4gICAgICAgIHN1Y2Nlc3MoZGF0YSkge1xuICAgICAgICAgIGV4dGVybmFsTGluay5hdHRyKCdocmVmJywgZGF0YS51cmwpOyAvLyBvcGVuIGFic29sdXRlIChleHRlcm5hbCkgbGlua3MgaW4gYSBuZXcgdGFiL3dpbmRvdyBhbmQgcmVsYXRpdmUgKGxvY2FsKSBsaW5rc1xuICAgICAgICAgIC8vIGRpcmVjdGx5XG5cbiAgICAgICAgICBpZiAoL14oPzpbYS16XSs6KT9cXC9cXC8vLnRlc3QoZGF0YS51cmwpKSB7XG4gICAgICAgICAgICBleHRlcm5hbExpbmsuYXR0cigndGFyZ2V0JywgJ19ibGFuaycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4dGVybmFsTGluay5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICBsaW5rVG9vbHRpcC50b29sdGlwKCdkaXNhYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3IoZGF0YSkge1xuICAgICAgICAgIGxpbmtUb29sdGlwLnRvb2x0aXAoJ2hpZGUnKS5hdHRyKCd0aXRsZScsIGRhdGEucmVzcG9uc2VKU09OLmVycm9yKS50b29sdGlwKCdmaXhUaXRsZScpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgICAgbWFya3VwQXJyLnB1c2gobGlua1Rvb2x0aXApO1xuICAgIH0pO1xuICAgIGNvbnN0IGV4dHJhTGlua3NTcGFuID0gJCgnI2V4dHJhX2xpbmtzJyk7XG4gICAgZXh0cmFMaW5rc1NwYW4ucHJldignaHInKS5zaG93KCk7XG4gICAgZXh0cmFMaW5rc1NwYW4uYXBwZW5kKG1hcmt1cEFycikuc2hvdygpO1xuICAgIGV4dHJhTGlua3NTcGFuLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIl0nKS50b29sdGlwKCk7XG4gIH1cbn0gLy8gU3dpdGNoIHRoZSBtb2RhbCBmcm9tIGEgbWFwcGVkIHRhc2sgc3VtbWFyeSB0byBhIHNwZWNpZmljIG1hcHBlZCB0YXNrIGluc3RhbmNlXG5cbiQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcubWFwX2luZGV4X2l0ZW0nLCBmdW5jdGlvbiBtYXBJdGVtKCkge1xuICBjb25zdCBtaSA9ICQodGhpcykuYXR0cignZGF0YS1tYXBJbmRleCcpO1xuXG4gIGlmIChtaSA9PT0gJ2FsbCcpIHtcbiAgICBjYWxsTW9kYWwoe1xuICAgICAgdGFza0lkLFxuICAgICAgZXhlY3V0aW9uRGF0ZSxcbiAgICAgIGRhZ1J1bklkLFxuICAgICAgbWFwSW5kZXg6IC0xLFxuICAgICAgaXNNYXBwZWQ6IHRydWUsXG4gICAgICBtYXBwZWRTdGF0ZXM6IG1hcFN0YXRlc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbGxNb2RhbCh7XG4gICAgICB0YXNrSWQsXG4gICAgICBleGVjdXRpb25EYXRlLFxuICAgICAgZGFnUnVuSWQsXG4gICAgICBtYXBJbmRleDogbWlcbiAgICB9KTtcbiAgfVxufSk7IC8vIFRhc2sgSW5zdGFuY2UgTW9kYWwgYWN0aW9uc1xuXG4kKCdmb3JtW2RhdGEtYWN0aW9uXScpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiBzdWJtaXQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IGZvcm0gPSAkKHRoaXMpLmdldCgwKTtcblxuICBpZiAoZGFnUnVuSWQgfHwgZXhlY3V0aW9uRGF0ZSkge1xuICAgIGlmIChmb3JtLmRhZ19ydW5faWQpIHtcbiAgICAgIGZvcm0uZGFnX3J1bl9pZC52YWx1ZSA9IGRhZ1J1bklkO1xuICAgIH1cblxuICAgIGlmIChmb3JtLmV4ZWN1dGlvbl9kYXRlKSB7XG4gICAgICBmb3JtLmV4ZWN1dGlvbl9kYXRlLnZhbHVlID0gZXhlY3V0aW9uRGF0ZTtcbiAgICB9XG5cbiAgICBmb3JtLm9yaWdpbi52YWx1ZSA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIGlmIChmb3JtLnRhc2tfaWQpIHtcbiAgICAgIGZvcm0udGFza19pZC52YWx1ZSA9IHRhc2tJZDtcbiAgICB9XG5cbiAgICBpZiAoZm9ybS5tYXBfaW5kZXggJiYgbWFwSW5kZXggPj0gMCkge1xuICAgICAgZm9ybS5tYXBfaW5kZXgudmFsdWUgPSBtYXBJbmRleDtcbiAgICB9IGVsc2UgaWYgKGZvcm0ubWFwX2luZGV4KSB7XG4gICAgICBmb3JtLm1hcF9pbmRleC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmb3JtLmFjdGlvbiA9ICQodGhpcykuZGF0YSgnYWN0aW9uJyk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxufSk7XG4kKCcjcGF1c2VfcmVzdW1lJykub24oJ2NoYW5nZScsIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICBjb25zdCAkaW5wdXQgPSAkKHRoaXMpO1xuICBjb25zdCBpZCA9ICRpbnB1dC5kYXRhKCdkYWctaWQnKTtcbiAgY29uc3QgaXNQYXVzZWQgPSAkaW5wdXQuaXMoJzpjaGVja2VkJyk7XG4gIGNvbnN0IHVybCA9IGAke3BhdXNlZFVybH0/aXNfcGF1c2VkPSR7aXNQYXVzZWR9JmRhZ19pZD0ke2VuY29kZVVSSUNvbXBvbmVudChpZCl9YDsgLy8gUmVtb3ZlIGZvY3VzIG9uIGVsZW1lbnQgc28gdGhlIHRvb2x0aXAgd2lsbCBnbyBhd2F5XG5cbiAgJGlucHV0LnRyaWdnZXIoJ2JsdXInKTtcbiAgJGlucHV0LnJlbW92ZUNsYXNzKCdzd2l0Y2gtaW5wdXQtLWVycm9yJyk7IC8vIGRpc3BhdGNoIGFuIGV2ZW50IHRoYXQgUmVhY3QgY2FuIGxpc3RlbiBmb3JcblxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgncGF1c2VkJywge1xuICAgIGRldGFpbDogaXNQYXVzZWRcbiAgfSk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAkLnBvc3QodXJsKS5mYWlsKCgpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICRpbnB1dC5wcm9wKCdjaGVja2VkJywgIWlzUGF1c2VkKTtcbiAgICAgICRpbnB1dC5hZGRDbGFzcygnc3dpdGNoLWlucHV0LS1lcnJvcicpO1xuICAgICAgZXZlbnQudmFsdWUgPSAhaXNQYXVzZWQ7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9LCA1MDApO1xuICB9KTtcbn0pO1xuJCgnI25leHQtcnVuJykub24oJ21vdXNlb3ZlcicsICgpID0+IHtcbiAgJCgnI25leHQtcnVuJykuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICgpID0+IHtcbiAgICBsZXQgbmV3VGl0bGUgPSAnJztcblxuICAgIGlmIChuZXh0UnVuLmNyZWF0ZUFmdGVyKSB7XG4gICAgICBuZXdUaXRsZSArPSBgPHN0cm9uZz5SdW4gQWZ0ZXI6PC9zdHJvbmc+ICR7Zm9ybWF0RGF0ZVRpbWUobmV4dFJ1bi5jcmVhdGVBZnRlcil9PGJyPmA7XG4gICAgICBuZXdUaXRsZSArPSBgTmV4dCBSdW46ICR7YXBwcm94VGltZUZyb21Ob3cobmV4dFJ1bi5jcmVhdGVBZnRlcil9PGJyPjxicj5gO1xuICAgIH1cblxuICAgIGlmIChuZXh0UnVuLmludGVydmFsU3RhcnQgJiYgbmV4dFJ1bi5pbnRlcnZhbEVuZCkge1xuICAgICAgbmV3VGl0bGUgKz0gJzxzdHJvbmc+RGF0YSBJbnRlcnZhbDwvc3Ryb25nPjxicj4nO1xuICAgICAgbmV3VGl0bGUgKz0gYFN0YXJ0OiAke2Zvcm1hdERhdGVUaW1lKG5leHRSdW4uaW50ZXJ2YWxTdGFydCl9PGJyPmA7XG4gICAgICBuZXdUaXRsZSArPSBgRW5kOiAke2Zvcm1hdERhdGVUaW1lKG5leHRSdW4uaW50ZXJ2YWxFbmQpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1RpdGxlO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./static/js/dag.js\n");

/***/ }),

/***/ "./static/js/datetime_utils.js":
/*!*************************************!*\
  !*** ./static/js/datetime_utils.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TimezoneEvent\": () => (/* binding */ TimezoneEvent),\n/* harmony export */   \"approxTimeFromNow\": () => (/* binding */ approxTimeFromNow),\n/* harmony export */   \"convertAndFormatUTC\": () => (/* binding */ convertAndFormatUTC),\n/* harmony export */   \"dateTimeAttrFormat\": () => (/* binding */ dateTimeAttrFormat),\n/* harmony export */   \"defaultFormat\": () => (/* binding */ defaultFormat),\n/* harmony export */   \"defaultFormatWithTZ\": () => (/* binding */ defaultFormatWithTZ),\n/* harmony export */   \"defaultTZFormat\": () => (/* binding */ defaultTZFormat),\n/* harmony export */   \"formatDateTime\": () => (/* binding */ formatDateTime),\n/* harmony export */   \"formatDuration\": () => (/* binding */ formatDuration),\n/* harmony export */   \"formatTimezone\": () => (/* binding */ formatTimezone),\n/* harmony export */   \"getDuration\": () => (/* binding */ getDuration),\n/* harmony export */   \"isoDateToTimeEl\": () => (/* binding */ isoDateToTimeEl),\n/* harmony export */   \"isoFormatWithoutTZ\": () => (/* binding */ isoFormatWithoutTZ),\n/* harmony export */   \"secondsToString\": () => (/* binding */ secondsToString),\n/* harmony export */   \"setDisplayedTimezone\": () => (/* binding */ setDisplayedTimezone),\n/* harmony export */   \"updateAllDateTimes\": () => (/* binding */ updateAllDateTimes)\n/* harmony export */ });\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* global moment, $, document */\nconst defaultFormat = 'YYYY-MM-DD, HH:mm:ss';\nconst isoFormatWithoutTZ = 'YYYY-MM-DDTHH:mm:ss.SSS';\nconst defaultFormatWithTZ = 'YYYY-MM-DD, HH:mm:ss z';\nconst defaultTZFormat = 'z (Z)';\nconst dateTimeAttrFormat = 'YYYY-MM-DDThh:mm:ssTZD';\nconst TimezoneEvent = 'timezone';\nfunction formatTimezone(what) {\n  if (what instanceof moment) {\n    return what.isUTC() ? 'UTC' : what.format(defaultTZFormat);\n  }\n\n  if (what === 'UTC') {\n    return what;\n  }\n\n  return moment().tz(what).format(defaultTZFormat);\n}\nfunction isoDateToTimeEl(datetime, options) {\n  const dateTimeObj = moment(datetime);\n  const addTitle = $.extend({\n    title: true\n  }, options).title;\n  const el = document.createElement('time');\n  el.setAttribute('datetime', dateTimeObj.format());\n\n  if (addTitle) {\n    el.setAttribute('title', dateTimeObj.isUTC() ? '' : `UTC: ${dateTimeObj.clone().utc().format()}`);\n  }\n\n  el.innerText = dateTimeObj.format(defaultFormat);\n  return el;\n}\nconst formatDateTime = datetime => moment(datetime).format(defaultFormatWithTZ);\nconst convertAndFormatUTC = (datetime, tz) => {\n  let dateTimeObj = moment.utc(datetime);\n  if (tz) dateTimeObj = dateTimeObj.tz(tz);\n  return dateTimeObj.format(defaultFormatWithTZ);\n};\nconst secondsToString = seconds => {\n  const numdays = Math.floor(seconds % 31536000 / 86400);\n  const numhours = Math.floor(seconds % 31536000 % 86400 / 3600);\n  const numminutes = Math.floor(seconds % 31536000 % 86400 % 3600 / 60);\n  const numseconds = Math.floor(seconds % 31536000 % 86400 % 3600 % 60);\n  return (numdays > 0 ? numdays + (numdays === 1 ? ' day ' : ' days ') : '') + (numhours > 0 ? numhours + (numhours === 1 ? ' hour ' : ' hours ') : '') + (numminutes > 0 ? numminutes + (numminutes === 1 ? ' minute ' : ' minutes ') : '') + (numseconds > 0 ? numseconds + (numseconds === 1 ? ' second' : ' seconds') : '');\n};\nfunction updateAllDateTimes() {\n  // Called after `moment.tz.setDefault` has changed the default TZ to display.\n  $('time[data-datetime-convert!=\"false\"]').each((_, el) => {\n    const $el = $(el);\n    const dt = moment($el.attr('datetime')); // eslint-disable-next-line no-underscore-dangle\n\n    if (dt._isValid) {\n      $el.text(dt.format($el.data('with-tz') ? defaultFormatWithTZ : defaultFormat));\n    }\n\n    if ($el.attr('title') !== undefined) {\n      // If displayed date is not UTC, have the UTC date in a title attribute\n      $el.attr('title', dt.isUTC() ? '' : `UTC: ${dt.clone().utc().format()}`);\n    }\n  }); // Update any date-time inputs.\n  //\n  // Since we have set the default timezone for moment, it will automatically\n  // convert it to the new target for us\n\n  $('.datetime input').each((_, el) => {\n    el.value = moment(el.value).format();\n  });\n}\nfunction setDisplayedTimezone(tz) {\n  moment.tz.setDefault(tz);\n  updateAllDateTimes();\n} // moment will resolve the enddate to now if it is undefined\n\nconst getDuration = (startDate, endDate) => moment(endDate || undefined).diff(startDate || undefined);\nconst formatDuration = dur => {\n  const duration = moment.duration(dur);\n  const days = duration.days(); // .as('milliseconds') is necessary for .format() to work correctly\n\n  return `${days > 0 ? `${days}d` : ''}${moment.utc(duration.as('milliseconds')).format('HH:mm:ss')}`;\n};\nconst approxTimeFromNow = dur => {\n  const timefromNow = moment(dur);\n  return `${timefromNow.fromNow()}`;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvZGF0ZXRpbWVfdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BaXJmbG93Ly4vc3RhdGljL2pzL2RhdGV0aW1lX3V0aWxzLmpzPzk4YTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBnbG9iYWwgbW9tZW50LCAkLCBkb2N1bWVudCAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERCwgSEg6bW06c3MnO1xuZXhwb3J0IGNvbnN0IGlzb0Zvcm1hdFdpdGhvdXRUWiA9ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUyc7XG5leHBvcnQgY29uc3QgZGVmYXVsdEZvcm1hdFdpdGhUWiA9ICdZWVlZLU1NLURELCBISDptbTpzcyB6JztcbmV4cG9ydCBjb25zdCBkZWZhdWx0VFpGb3JtYXQgPSAneiAoWiknO1xuZXhwb3J0IGNvbnN0IGRhdGVUaW1lQXR0ckZvcm1hdCA9ICdZWVlZLU1NLUREVGhoOm1tOnNzVFpEJztcbmV4cG9ydCBjb25zdCBUaW1lem9uZUV2ZW50ID0gJ3RpbWV6b25lJztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lem9uZSh3aGF0KSB7XG4gIGlmICh3aGF0IGluc3RhbmNlb2YgbW9tZW50KSB7XG4gICAgcmV0dXJuIHdoYXQuaXNVVEMoKSA/ICdVVEMnIDogd2hhdC5mb3JtYXQoZGVmYXVsdFRaRm9ybWF0KTtcbiAgfVxuXG4gIGlmICh3aGF0ID09PSAnVVRDJykge1xuICAgIHJldHVybiB3aGF0O1xuICB9XG5cbiAgcmV0dXJuIG1vbWVudCgpLnR6KHdoYXQpLmZvcm1hdChkZWZhdWx0VFpGb3JtYXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb0RhdGVUb1RpbWVFbChkYXRldGltZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRlVGltZU9iaiA9IG1vbWVudChkYXRldGltZSk7XG4gIGNvbnN0IGFkZFRpdGxlID0gJC5leHRlbmQoe1xuICAgIHRpdGxlOiB0cnVlXG4gIH0sIG9wdGlvbnMpLnRpdGxlO1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RpbWUnKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdkYXRldGltZScsIGRhdGVUaW1lT2JqLmZvcm1hdCgpKTtcblxuICBpZiAoYWRkVGl0bGUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZGF0ZVRpbWVPYmouaXNVVEMoKSA/ICcnIDogYFVUQzogJHtkYXRlVGltZU9iai5jbG9uZSgpLnV0YygpLmZvcm1hdCgpfWApO1xuICB9XG5cbiAgZWwuaW5uZXJUZXh0ID0gZGF0ZVRpbWVPYmouZm9ybWF0KGRlZmF1bHRGb3JtYXQpO1xuICByZXR1cm4gZWw7XG59XG5leHBvcnQgY29uc3QgZm9ybWF0RGF0ZVRpbWUgPSBkYXRldGltZSA9PiBtb21lbnQoZGF0ZXRpbWUpLmZvcm1hdChkZWZhdWx0Rm9ybWF0V2l0aFRaKTtcbmV4cG9ydCBjb25zdCBjb252ZXJ0QW5kRm9ybWF0VVRDID0gKGRhdGV0aW1lLCB0eikgPT4ge1xuICBsZXQgZGF0ZVRpbWVPYmogPSBtb21lbnQudXRjKGRhdGV0aW1lKTtcbiAgaWYgKHR6KSBkYXRlVGltZU9iaiA9IGRhdGVUaW1lT2JqLnR6KHR6KTtcbiAgcmV0dXJuIGRhdGVUaW1lT2JqLmZvcm1hdChkZWZhdWx0Rm9ybWF0V2l0aFRaKTtcbn07XG5leHBvcnQgY29uc3Qgc2Vjb25kc1RvU3RyaW5nID0gc2Vjb25kcyA9PiB7XG4gIGNvbnN0IG51bWRheXMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSAzMTUzNjAwMCAvIDg2NDAwKTtcbiAgY29uc3QgbnVtaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSAzMTUzNjAwMCAlIDg2NDAwIC8gMzYwMCk7XG4gIGNvbnN0IG51bW1pbnV0ZXMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSAzMTUzNjAwMCAlIDg2NDAwICUgMzYwMCAvIDYwKTtcbiAgY29uc3QgbnVtc2Vjb25kcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAlIDMxNTM2MDAwICUgODY0MDAgJSAzNjAwICUgNjApO1xuICByZXR1cm4gKG51bWRheXMgPiAwID8gbnVtZGF5cyArIChudW1kYXlzID09PSAxID8gJyBkYXkgJyA6ICcgZGF5cyAnKSA6ICcnKSArIChudW1ob3VycyA+IDAgPyBudW1ob3VycyArIChudW1ob3VycyA9PT0gMSA/ICcgaG91ciAnIDogJyBob3VycyAnKSA6ICcnKSArIChudW1taW51dGVzID4gMCA/IG51bW1pbnV0ZXMgKyAobnVtbWludXRlcyA9PT0gMSA/ICcgbWludXRlICcgOiAnIG1pbnV0ZXMgJykgOiAnJykgKyAobnVtc2Vjb25kcyA+IDAgPyBudW1zZWNvbmRzICsgKG51bXNlY29uZHMgPT09IDEgPyAnIHNlY29uZCcgOiAnIHNlY29uZHMnKSA6ICcnKTtcbn07XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWxsRGF0ZVRpbWVzKCkge1xuICAvLyBDYWxsZWQgYWZ0ZXIgYG1vbWVudC50ei5zZXREZWZhdWx0YCBoYXMgY2hhbmdlZCB0aGUgZGVmYXVsdCBUWiB0byBkaXNwbGF5LlxuICAkKCd0aW1lW2RhdGEtZGF0ZXRpbWUtY29udmVydCE9XCJmYWxzZVwiXScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgY29uc3QgZHQgPSBtb21lbnQoJGVsLmF0dHIoJ2RhdGV0aW1lJykpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcblxuICAgIGlmIChkdC5faXNWYWxpZCkge1xuICAgICAgJGVsLnRleHQoZHQuZm9ybWF0KCRlbC5kYXRhKCd3aXRoLXR6JykgPyBkZWZhdWx0Rm9ybWF0V2l0aFRaIDogZGVmYXVsdEZvcm1hdCkpO1xuICAgIH1cblxuICAgIGlmICgkZWwuYXR0cigndGl0bGUnKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBkaXNwbGF5ZWQgZGF0ZSBpcyBub3QgVVRDLCBoYXZlIHRoZSBVVEMgZGF0ZSBpbiBhIHRpdGxlIGF0dHJpYnV0ZVxuICAgICAgJGVsLmF0dHIoJ3RpdGxlJywgZHQuaXNVVEMoKSA/ICcnIDogYFVUQzogJHtkdC5jbG9uZSgpLnV0YygpLmZvcm1hdCgpfWApO1xuICAgIH1cbiAgfSk7IC8vIFVwZGF0ZSBhbnkgZGF0ZS10aW1lIGlucHV0cy5cbiAgLy9cbiAgLy8gU2luY2Ugd2UgaGF2ZSBzZXQgdGhlIGRlZmF1bHQgdGltZXpvbmUgZm9yIG1vbWVudCwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIGNvbnZlcnQgaXQgdG8gdGhlIG5ldyB0YXJnZXQgZm9yIHVzXG5cbiAgJCgnLmRhdGV0aW1lIGlucHV0JykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBlbC52YWx1ZSA9IG1vbWVudChlbC52YWx1ZSkuZm9ybWF0KCk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldERpc3BsYXllZFRpbWV6b25lKHR6KSB7XG4gIG1vbWVudC50ei5zZXREZWZhdWx0KHR6KTtcbiAgdXBkYXRlQWxsRGF0ZVRpbWVzKCk7XG59IC8vIG1vbWVudCB3aWxsIHJlc29sdmUgdGhlIGVuZGRhdGUgdG8gbm93IGlmIGl0IGlzIHVuZGVmaW5lZFxuXG5leHBvcnQgY29uc3QgZ2V0RHVyYXRpb24gPSAoc3RhcnREYXRlLCBlbmREYXRlKSA9PiBtb21lbnQoZW5kRGF0ZSB8fCB1bmRlZmluZWQpLmRpZmYoc3RhcnREYXRlIHx8IHVuZGVmaW5lZCk7XG5leHBvcnQgY29uc3QgZm9ybWF0RHVyYXRpb24gPSBkdXIgPT4ge1xuICBjb25zdCBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkdXIpO1xuICBjb25zdCBkYXlzID0gZHVyYXRpb24uZGF5cygpOyAvLyAuYXMoJ21pbGxpc2Vjb25kcycpIGlzIG5lY2Vzc2FyeSBmb3IgLmZvcm1hdCgpIHRvIHdvcmsgY29ycmVjdGx5XG5cbiAgcmV0dXJuIGAke2RheXMgPiAwID8gYCR7ZGF5c31kYCA6ICcnfSR7bW9tZW50LnV0YyhkdXJhdGlvbi5hcygnbWlsbGlzZWNvbmRzJykpLmZvcm1hdCgnSEg6bW06c3MnKX1gO1xufTtcbmV4cG9ydCBjb25zdCBhcHByb3hUaW1lRnJvbU5vdyA9IGR1ciA9PiB7XG4gIGNvbnN0IHRpbWVmcm9tTm93ID0gbW9tZW50KGR1cik7XG4gIHJldHVybiBgJHt0aW1lZnJvbU5vdy5mcm9tTm93KCl9YDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./static/js/datetime_utils.js\n");

/***/ }),

/***/ "./static/js/graph.js":
/*!****************************!*\
  !*** ./static/js/graph.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./static/js/utils.js\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ \"./static/js/main.js\");\n/* harmony import */ var _task_instances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./task_instances */ \"./static/js/task_instances.js\");\n/* harmony import */ var _dag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dag */ \"./static/js/dag.js\");\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-use-before-define */\n\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/*\n  global d3, document, nodes, taskInstances, tasks, edges, dagreD3, localStorage, $,\n  autoRefreshInterval, moment, convertSecsToHumanReadable\n*/\n\n\n\n // dagId comes from dag.html\n\nconst dagId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('dag_id');\nconst executionDate = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('execution_date');\nconst dagRunId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('dag_run_id');\nconst arrange = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('arrange');\nconst taskInstancesUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('task_instances_url');\nconst isSchedulerRunning = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getMetaValue)('is_scheduler_running'); // This maps the actual taskId to the current graph node id that contains the task\n// (because tasks may be grouped into a group node)\n\nconst mapTaskToNode = new Map(); // Below variables are being used in dag.js\n\nconst getTaskInstanceURL = `${taskInstancesUrl}?dag_id=${encodeURIComponent(dagId)}&execution_date=${encodeURIComponent(executionDate)}`;\nconst duration = 500;\nconst stateFocusMap = {\n  success: false,\n  running: false,\n  failed: false,\n  skipped: false,\n  upstream_failed: false,\n  up_for_reschedule: false,\n  up_for_retry: false,\n  queued: false,\n  deferred: false,\n  no_status: false\n};\n\nconst checkRunState = () => {\n  const states = Object.values(taskInstances).map(ti => ti.state);\n  return !states.some(state => ['success', 'failed', 'upstream_failed', 'skipped', 'removed'].indexOf(state) === -1);\n};\n\nconst taskTip = d3.tip().attr('class', 'tooltip d3-tip').html(toolTipHtml => toolTipHtml); // Preparation of DagreD3 data structures\n// \"compound\" is set to true to make use of clusters to display TaskGroup.\n\nconst g = new dagreD3.graphlib.Graph({\n  compound: true\n}).setGraph({\n  nodesep: 30,\n  ranksep: 15,\n  rankdir: arrange\n}).setDefaultEdgeLabel(() => ({\n  lineInterpolate: 'basis'\n}));\nconst render = dagreD3.render();\nconst svg = d3.select('#graph-svg');\nlet innerSvg = d3.select('#graph-svg g'); // We modify the label of task map nodes to include the brackets and a count of mapped tasks\n// returns true if at least one node is changed\n\nconst updateNodeLabels = (node, instances) => {\n  let haveLabelsChanged = false;\n  let {\n    label\n  } = node.value; // Check if there is a count of mapped instances\n\n  if (tasks[node.id] && tasks[node.id].is_mapped) {\n    const count = instances[node.id] && instances[node.id].mapped_states ? instances[node.id].mapped_states.length : ' ';\n    label = `${node.id} [${count}]`;\n  }\n\n  if (g.node(node.id) && g.node(node.id).label !== label) {\n    g.node(node.id).label = label;\n    haveLabelsChanged = true;\n  }\n\n  if (node.children) {\n    // Iterate through children and return true if at least one has been changed\n    const updatedNodes = node.children.map(n => updateNodeLabels(n, instances));\n    return updatedNodes.some(changed => changed);\n  }\n\n  return haveLabelsChanged;\n}; // Remove the node with this nodeId from g.\n\n\nfunction removeNode(nodeId) {\n  if (g.hasNode(nodeId)) {\n    const node = g.node(nodeId);\n\n    if (node.children !== undefined) {\n      // If the child is an expanded group node, remove children too.\n      node.children.forEach(child => {\n        removeNode(child.id);\n      });\n    }\n  }\n\n  g.removeNode(nodeId);\n} // Collapse the children of the given group node.\n\n\nfunction collapseGroup(nodeId, node) {\n  // Remove children nodes\n  node.children.forEach(child => {\n    removeNode(child.id);\n  }); // Map task that are under this node to this node's id\n\n  getChildrenIds(node).forEach(childId => mapTaskToNode.set(childId, nodeId));\n  node = g.node(nodeId); // Set children edges onto the group edge\n\n  edges.forEach(edge => {\n    const sourceId = mapTaskToNode.get(edge.source_id);\n    const targetId = mapTaskToNode.get(edge.target_id);\n\n    if (sourceId !== targetId && !g.hasEdge(sourceId, targetId)) {\n      g.setEdge(sourceId, targetId, {\n        curve: d3.curveBasis,\n        arrowheadClass: 'arrowhead'\n      });\n    }\n  });\n  draw();\n  focusGroup(nodeId);\n  removeExpandedGroup(nodeId, node);\n} // Update the page to show the latest DAG.\n\n\nfunction draw() {\n  innerSvg.remove();\n  innerSvg = svg.append('g'); // Run the renderer. This is what draws the final graph.\n\n  innerSvg.call(render, g);\n  innerSvg.call(taskTip); // When an expanded group is clicked, collapse it.\n\n  d3.selectAll('g.cluster').on('click', nodeId => {\n    if (d3.event.defaultPrevented) return;\n    const node = g.node(nodeId);\n    collapseGroup(nodeId, node);\n  }); // When a node is clicked, action depends on the node type.\n\n  d3.selectAll('g.node').on('click', nodeId => {\n    const node = g.node(nodeId);\n\n    if (node.children !== undefined && Object.keys(node.children).length > 0) {\n      // A group node\n      if (d3.event.defaultPrevented) return;\n      expandGroup(nodeId, node);\n      updateNodeLabels(nodes, taskInstances);\n      draw();\n      focusGroup(nodeId);\n    } else if (nodeId in taskInstances) {\n      // A task node\n      const task = tasks[nodeId];\n      const tryNumber = taskInstances[nodeId].try_number || 0;\n      let mappedStates = [];\n      if (task.is_mapped) mappedStates = taskInstances[nodeId].mapped_states;\n      (0,_dag__WEBPACK_IMPORTED_MODULE_3__.callModal)({\n        taskId: nodeId,\n        executionDate,\n        extraLinks: task.extra_links,\n        tryNumber,\n        isSubDag: task.task_type === 'SubDagOperator',\n        dagRunId,\n        mapIndex: task.map_index,\n        isMapped: task.is_mapped,\n        mappedStates\n      });\n    }\n  });\n  d3.selectAll('g.node').on('mouseover', function mousover(d) {\n    d3.select(this).selectAll('rect').attr('data-highlight', 'highlight');\n    highlightNodes(g.predecessors(d));\n    highlightNodes(g.successors(d));\n    const adjacentNodeNames = [d, ...g.predecessors(d), ...g.successors(d)];\n    d3.selectAll('g.nodes g.node').filter(x => !adjacentNodeNames.includes(x)).attr('data-highlight', 'fade');\n    d3.selectAll('g.edgePath')[0].forEach(x => {\n      const val = g.nodeEdges(d).includes(x.__data__) ? 'highlight' : 'fade';\n      d3.select(x).attr('data-highlight', val);\n    });\n    d3.selectAll('g.edgeLabel')[0].forEach(x => {\n      if (!g.nodeEdges(d).includes(x.__data__)) {\n        d3.select(x).attr('data-highlight', 'fade');\n      }\n    });\n  });\n  d3.selectAll('g.node').on('mouseout', function mouseout(d) {\n    d3.select(this).selectAll('rect, circle').attr('data-highlight', null);\n    unHighlightNodes(g.predecessors(d));\n    unHighlightNodes(g.successors(d));\n    d3.selectAll('g.node, g.edgePath, g.edgeLabel').attr('data-highlight', null);\n    localStorage.removeItem(focusedGroupKey(dagId));\n  });\n  updateNodesStates(taskInstances);\n  setUpZoomSupport();\n}\n\nlet zoom = null;\n\nfunction setUpZoomSupport() {\n  // Set up zoom support for Graph\n  zoom = d3.behavior.zoom().on('zoom', () => {\n    innerSvg.attr('transform', `translate(${d3.event.translate})scale(${d3.event.scale})`);\n  });\n  svg.call(zoom); // Centering the DAG on load\n  // Get Dagre Graph dimensions\n\n  const graphWidth = g.graph().width;\n  const graphHeight = g.graph().height; // Get SVG dimensions\n\n  const padding = 80;\n  const svgBb = svg.node().getBoundingClientRect();\n  const width = svgBb.width - padding * 2;\n  const height = svgBb.height - padding; // we are not centering the dag vertically\n  // Calculate applicable scale for zoom\n\n  const zoomScale = Math.min(Math.min(width / graphWidth, height / graphHeight), 1.5 // cap zoom level to 1.5 so nodes are not too large\n  );\n  zoom.translate([width / 2 - graphWidth * zoomScale / 2 + padding, padding]);\n  zoom.scale(zoomScale);\n  zoom.event(innerSvg);\n}\n\nfunction highlightNodes(nodes) {\n  nodes.forEach(nodeid => {\n    const myNode = g.node(nodeid).elem;\n    d3.select(myNode).selectAll('rect, circle').attr('data-highlight', 'highlight');\n  });\n}\n\nfunction unHighlightNodes(nodes) {\n  nodes.forEach(nodeid => {\n    const myNode = g.node(nodeid).elem;\n    d3.select(myNode).selectAll('rect, circle').attr('data-highlight', null);\n  });\n}\n\nd3.selectAll('.js-state-legend-item').on('mouseover', function mouseover() {\n  if (!stateIsSet()) {\n    const state = $(this).data('state');\n    focusState(state);\n  }\n}).on('mouseout', () => {\n  if (!stateIsSet()) {\n    clearFocus();\n  }\n});\nd3.selectAll('.js-state-legend-item').on('click', function click() {\n  const state = $(this).data('state');\n  clearFocus();\n\n  if (!stateFocusMap[state]) {\n    const color = d3.select(this).style('border-color');\n    focusState(state, this, color);\n    setFocusMap(state);\n  } else {\n    setFocusMap();\n    d3.selectAll('.js-state-legend-item').style('background-color', null);\n  }\n}); // Returns true if a node's id or its children's id matches searchText\n\nfunction nodeMatches(nodeId, searchText) {\n  if (nodeId.indexOf(searchText) > -1) return true; // The node's own id does not match, it may have children that match\n\n  const node = g.node(nodeId);\n\n  if (node.children) {\n    const children = getChildrenIds(node);\n    return !!children.find(child => child.indexOf(searchText) > -1);\n  }\n\n  return false;\n}\n\nd3.select('#searchbox').on('keyup', () => {\n  const s = document.getElementById('searchbox').value;\n  if (s === '') return;\n  let match = null;\n\n  if (stateIsSet()) {\n    clearFocus();\n    setFocusMap();\n  }\n\n  d3.selectAll('g.nodes g.node').filter(function highlight(d) {\n    if (s === '') {\n      d3.selectAll('g.edgePaths, g.edgeLabel').attr('data-highlight', null);\n      d3.select(this).attr('data-highlight', null);\n    } else {\n      d3.selectAll('g.edgePaths, g.edgeLabel').attr('data-highlight', 'fade');\n\n      if (nodeMatches(d, s)) {\n        if (!match) match = this;\n        d3.select(this).attr('data-highlight', null);\n      } else {\n        d3.select(this).attr('data-highlight', 'fade');\n      }\n    } // We don't actually use the returned results from filter\n\n\n    return null;\n  }); // This moves the matched node to the center of the graph area\n\n  if (match) {\n    const transform = d3.transform(d3.select(match).attr('transform'));\n    const svgBb = svg.node().getBoundingClientRect();\n    transform.translate = [svgBb.width / 2 - transform.translate[0], svgBb.height / 2 - transform.translate[1]];\n    transform.scale = [1, 1];\n\n    if (zoom != null) {\n      zoom.translate(transform.translate);\n      zoom.scale(1);\n      zoom.event(innerSvg);\n    }\n  }\n});\n\nfunction clearFocus() {\n  d3.selectAll('g.node, g.edgePaths, g.edgeLabel').attr('data-highlight', null);\n  localStorage.removeItem(focusedGroupKey(dagId));\n}\n\nfunction focusState(state, node, color) {\n  d3.selectAll('g.node, g.edgePaths, g.edgeLabel').attr('data-highlight', 'fade');\n  d3.selectAll(`g.node.${state}`).attr('data-highlight', null);\n  d3.selectAll(`g.node.${state} rect`).attr('data-highlight', null);\n  d3.select(node).style('background-color', color);\n}\n\nfunction setFocusMap(state) {\n  Object.keys(stateFocusMap).forEach(key => {\n    if ({}.hasOwnProperty.call(stateFocusMap, key)) {\n      stateFocusMap[key] = false;\n    }\n  });\n\n  if (state != null) {\n    stateFocusMap[state] = true;\n  }\n}\n\nconst stateIsSet = () => !!Object.keys(stateFocusMap).find(key => stateFocusMap[key]);\n\nlet refreshInterval;\n\nfunction startOrStopRefresh() {\n  if ($('#auto_refresh').is(':checked')) {\n    refreshInterval = setInterval(() => {\n      handleRefresh();\n    }, autoRefreshInterval * 1000);\n  } else {\n    clearInterval(refreshInterval);\n  }\n} // pause autorefresh when the page is not active\n\n\nconst handleVisibilityChange = () => {\n  if (document.hidden) {\n    clearInterval(refreshInterval);\n  } else {\n    initRefresh();\n  }\n};\n\ndocument.addEventListener('visibilitychange', handleVisibilityChange);\nlet prevTis;\n\nfunction handleRefresh() {\n  $('#loading-dots').css('display', 'inline-block');\n  $.get(getTaskInstanceURL).done(tis => {\n    // only refresh if the data has changed\n    if (prevTis !== tis) {\n      // eslint-disable-next-line no-global-assign\n      taskInstances = JSON.parse(tis);\n      updateNodesStates(taskInstances); // Only redraw the graph if labels have changed\n\n      const haveLabelsChanged = updateNodeLabels(nodes, taskInstances);\n      if (haveLabelsChanged) draw(); // end refresh if all states are final\n\n      const isFinal = checkRunState();\n\n      if (isFinal) {\n        $('#auto_refresh').prop('checked', false);\n        clearInterval(refreshInterval);\n      }\n    }\n\n    prevTis = tis;\n    setTimeout(() => {\n      $('#loading-dots').hide();\n    }, 500);\n    $('#error').hide();\n  }).fail((response, textStatus, err) => {\n    const description = response.responseJSON && response.responseJSON.error || 'Something went wrong.';\n    $('#error_msg').text(`${textStatus}: ${err} ${description}`);\n    $('#error').show();\n    setTimeout(() => {\n      $('#loading-dots').hide();\n    }, 500);\n    $('#chart_section').hide(1000);\n    $('#datatable_section').hide(1000);\n  });\n}\n\n$('#auto_refresh').change(() => {\n  if ($('#auto_refresh').is(':checked')) {\n    // Run an initial refresh before starting interval if manually turned on\n    handleRefresh();\n    localStorage.removeItem('disableAutoRefresh');\n  } else {\n    localStorage.setItem('disableAutoRefresh', 'true');\n  }\n\n  startOrStopRefresh();\n});\n\nfunction initRefresh() {\n  const isDisabled = localStorage.getItem('disableAutoRefresh');\n  const isFinal = checkRunState();\n  $('#auto_refresh').prop('checked', !(isDisabled || isFinal) && isSchedulerRunning === 'True');\n  startOrStopRefresh();\n  d3.select('#refresh_button').on('click', () => handleRefresh());\n} // Generate tooltip for a group node\n\n\nfunction groupTooltip(node, tis) {\n  const numMap = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.finalStatesMap)();\n  let minStart;\n  let maxEnd;\n  getChildrenIds(node).forEach(child => {\n    if (child in tis) {\n      const ti = tis[child];\n\n      if (!minStart || moment(ti.start_date).isBefore(minStart)) {\n        minStart = moment(ti.start_date);\n      }\n\n      if (!maxEnd || moment(ti.end_date).isAfter(maxEnd)) {\n        maxEnd = moment(ti.end_date);\n      }\n\n      const stateKey = ti.state == null ? 'no_status' : ti.state;\n      if (numMap.has(stateKey)) numMap.set(stateKey, numMap.get(stateKey) + 1);\n    }\n  });\n  const groupDuration = convertSecsToHumanReadable(moment(maxEnd).diff(minStart, 'second'));\n  const tooltipText = node.tooltip ? `<p>${node.tooltip}</p>` : '';\n  let tt = `\n    ${tooltipText}\n    <strong>Duration:</strong> ${groupDuration} <br><br>\n  `;\n  numMap.forEach((key, val) => {\n    if (key > 0) {\n      tt += `<strong>${(0,_main__WEBPACK_IMPORTED_MODULE_1__.escapeHtml)(val)}:</strong> ${key} <br>`;\n    }\n  });\n  return tt;\n} // Assigning css classes based on state to nodes\n// Initiating the tooltips\n\n\nfunction updateNodesStates(tis) {\n  g.nodes().forEach(nodeId => {\n    const node = g.node(nodeId);\n    const {\n      elem\n    } = node;\n    const taskId = nodeId;\n\n    if (elem) {\n      const classes = `node enter ${getNodeState(nodeId, tis)}`;\n      elem.setAttribute('class', classes);\n      elem.setAttribute('data-toggle', 'tooltip');\n\n      elem.onmouseover = evt => {\n        let tt;\n\n        if (taskId in tis) {\n          tt = (0,_task_instances__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(tis[taskId]);\n        } else if (node.children) {\n          tt = groupTooltip(node, tis);\n        } else if (taskId in tasks) {\n          tt = (0,_task_instances__WEBPACK_IMPORTED_MODULE_2__.taskNoInstanceTooltip)(taskId, tasks[taskId]);\n          elem.setAttribute('class', `${classes} not-allowed`);\n        }\n\n        if (tt) taskTip.show(tt, evt.target); // taskTip is defined in graph.html\n      };\n\n      elem.onmouseout = taskTip.hide;\n      elem.onclick = taskTip.hide;\n    }\n  });\n} // Returns list of children id of the given task group\n\n\nfunction getChildrenIds(group) {\n  const children = [];\n  Object.values(group.children).forEach(value => {\n    if (value.children === undefined) {\n      // node\n      children.push(value.id);\n    } else {\n      // group\n      const subGroupChildren = getChildrenIds(value);\n      subGroupChildren.forEach(id => children.push(id));\n    }\n  });\n  return children;\n} // Return list of all task group ids in the given task group including the given group itself.\n\n\nfunction getAllGroupIds(group) {\n  const children = [group.id];\n  Object.entries(group.children).forEach(([, val]) => {\n    if (val.children !== undefined) {\n      // group\n      const subGroupChildren = getAllGroupIds(val);\n      subGroupChildren.forEach(id => children.push(id));\n    }\n  });\n  return children;\n} // Return the state for the node based on the state of its taskinstance or that of its\n// children if it's a group node\n\n\nfunction getNodeState(nodeId, tis) {\n  const node = g.node(nodeId);\n\n  if (node.children === undefined) {\n    if (nodeId in tis) {\n      return tis[nodeId].state || 'no_status';\n    }\n\n    return 'no_status';\n  }\n\n  const children = getChildrenIds(node);\n  const childrenStates = new Set();\n  children.forEach(taskId => {\n    if (taskId in tis) {\n      const {\n        state\n      } = tis[taskId];\n      childrenStates.add(state == null ? 'no_status' : state);\n    }\n  }); // In this order, if any of these states appeared in childrenStates, return it as\n  // the group state.\n\n  const priority = ['failed', 'upstream_failed', 'up_for_retry', 'up_for_reschedule', 'queued', 'scheduled', 'sensing', 'running', 'shutdown', 'restarting', 'removed', 'no_status', 'success', 'skipped'];\n  return priority.find(state => childrenStates.has(state)) || 'no_status';\n} // Returns the key used to store expanded task group ids in localStorage\n\n\nfunction expandedGroupsKey() {\n  return `expandedGroups_${dagId}`;\n} // Returns the key used to store the focused task group id in localStorage\n\n\nfunction focusedGroupKey() {\n  return `focused_group_${dagId}`;\n} // Focus the graph on the expanded/collapsed node\n\n\nfunction focusGroup(nodeId) {\n  if (nodeId != null && zoom != null) {\n    const {\n      x\n    } = g.node(nodeId); // This is the total canvas size.\n\n    const {\n      width,\n      height\n    } = svg.node().getBoundingClientRect(); // This is the size of the node or the cluster (i.e. group)\n\n    let rect = d3.selectAll('g.node').filter(n => n === nodeId).select('rect');\n    if (rect.empty()) rect = d3.selectAll('g.cluster').filter(n => n === nodeId).select('rect'); // Is there a better way to get nodeWidth and nodeHeight ?\n\n    const [nodeWidth, nodeHeight] = [rect[0][0].attributes.width.value, rect[0][0].attributes.height.value]; // Calculate zoom scale to fill most of the canvas with the node/cluster in focus.\n\n    const scale = Math.min(Math.min(width / nodeWidth, height / nodeHeight), 1.5 // cap zoom level to 1.5 so nodes are not too large\n    ) * 0.9; // deltaY of 5 keeps the zoom at the top of the view but with a slight margin\n\n    const [deltaX, deltaY] = [width / 2 - x * scale, 5];\n    zoom.translate([deltaX, deltaY]);\n    zoom.scale(scale);\n    zoom.event(innerSvg.transition().duration(duration));\n    const children = new Set(g.children(nodeId)); // Set data attr to highlight the focused group (via CSS).\n\n    d3.selectAll('g.nodes g.node').forEach(function cssHighlight(d) {\n      if (d === nodeId || children.has(d)) {\n        d3.select(this).attr('data-highlight', null);\n      } else {\n        d3.select(this).attr('data-highlight', 'fade');\n      }\n    });\n    localStorage.setItem(focusedGroupKey(dagId), nodeId);\n  }\n} // Expands a group node\n\n\nfunction expandGroup(nodeId, node) {\n  node.children.forEach(val => {\n    // Set children nodes\n    g.setNode(val.id, val.value);\n    mapTaskToNode.set(val.id, val.id);\n    g.node(val.id).id = val.id;\n\n    if (val.children !== undefined) {\n      // Set children attribute so that the group can be expanded later when needed.\n      const groupNode = g.node(val.id);\n      groupNode.children = val.children; // Map task that are under this node to this node's id\n\n      getChildrenIds(val).forEach(childId => mapTaskToNode.set(childId, val.id));\n    } // Only call setParent if node is not the root node.\n\n\n    if (nodeId != null) g.setParent(val.id, nodeId);\n  }); // Add edges\n\n  edges.forEach(edge => {\n    const sourceId = mapTaskToNode.get(edge.source_id);\n    const targetId = mapTaskToNode.get(edge.target_id);\n\n    if (sourceId !== targetId && !g.hasEdge(sourceId, targetId) && sourceId && targetId) {\n      g.setEdge(sourceId, targetId, {\n        curve: d3.curveBasis,\n        arrowheadClass: 'arrowhead',\n        label: edge.label\n      });\n    }\n  });\n  g.edges().forEach(edge => {\n    // Remove edges that were associated with the expanded group node..\n    if (nodeId === edge.v || nodeId === edge.w) {\n      g.removeEdge(edge.v, edge.w);\n    }\n  });\n  saveExpandedGroup(nodeId);\n}\n\nfunction getSavedGroups() {\n  let expandedGroups;\n\n  try {\n    expandedGroups = new Set(JSON.parse(localStorage.getItem(expandedGroupsKey(dagId))));\n  } catch {\n    expandedGroups = new Set();\n  }\n\n  return expandedGroups;\n} // Clean up invalid group_ids from saved_group_ids (e.g. due to DAG changes)\n\n\nfunction pruneInvalidSavedGroupIds() {\n  // All the groupIds in the whole DAG\n  const allGroupIds = new Set(getAllGroupIds(nodes));\n  let expandedGroups = getSavedGroups(dagId);\n  expandedGroups = Array.from(expandedGroups).filter(groupId => allGroupIds.has(groupId));\n  localStorage.setItem(expandedGroupsKey(dagId), JSON.stringify(expandedGroups));\n} // Remember the expanded groups in local storage so that it can be used\n// to restore the expanded state of task groups.\n\n\nfunction saveExpandedGroup(nodeId) {\n  // expandedGroups is a Set\n  const expandedGroups = getSavedGroups(dagId);\n  expandedGroups.add(nodeId);\n  localStorage.setItem(expandedGroupsKey(dagId), JSON.stringify(Array.from(expandedGroups)));\n} // Remove the nodeId from the expanded state\n\n\nfunction removeExpandedGroup(nodeId, node) {\n  const expandedGroups = getSavedGroups(dagId);\n  const childGroupIds = getAllGroupIds(node);\n  childGroupIds.forEach(childId => expandedGroups.delete(childId));\n  localStorage.setItem(expandedGroupsKey(dagId), JSON.stringify(Array.from(expandedGroups)));\n} // Restore previously expanded task groups\n\n\nfunction expandSavedGroups(expandedGroups, node) {\n  if (node.children === undefined) return;\n  node.children.forEach(childNode => {\n    if (expandedGroups.has(childNode.id)) {\n      expandGroup(childNode.id, g.node(childNode.id));\n      expandSavedGroups(expandedGroups, childNode);\n    }\n  });\n}\n\npruneInvalidSavedGroupIds();\nconst focusNodeId = localStorage.getItem(focusedGroupKey(dagId));\nconst expandedGroups = getSavedGroups(dagId); // Always expand the root node\n\nexpandGroup(null, nodes); // Expand the node that were previously expanded\n\nexpandSavedGroups(expandedGroups, nodes); // Draw once after all groups have been expanded\n\nupdateNodeLabels(nodes, taskInstances);\ndraw(); // Restore focus (if available)\n\nif (g.hasNode(focusNodeId)) {\n  focusGroup(focusNodeId);\n}\n\ninitRefresh();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvZ3JhcGguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQWlyZmxvdy8uL3N0YXRpYy9qcy9ncmFwaC5qcz9hZWNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbi8qIVxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypcbiAgZ2xvYmFsIGQzLCBkb2N1bWVudCwgbm9kZXMsIHRhc2tJbnN0YW5jZXMsIHRhc2tzLCBlZGdlcywgZGFncmVEMywgbG9jYWxTdG9yYWdlLCAkLFxuICBhdXRvUmVmcmVzaEludGVydmFsLCBtb21lbnQsIGNvbnZlcnRTZWNzVG9IdW1hblJlYWRhYmxlXG4qL1xuaW1wb3J0IHsgZ2V0TWV0YVZhbHVlLCBmaW5hbFN0YXRlc01hcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZXNjYXBlSHRtbCB9IGZyb20gJy4vbWFpbic7XG5pbXBvcnQgdGlUb29sdGlwLCB7IHRhc2tOb0luc3RhbmNlVG9vbHRpcCB9IGZyb20gJy4vdGFza19pbnN0YW5jZXMnO1xuaW1wb3J0IHsgY2FsbE1vZGFsIH0gZnJvbSAnLi9kYWcnOyAvLyBkYWdJZCBjb21lcyBmcm9tIGRhZy5odG1sXG5cbmNvbnN0IGRhZ0lkID0gZ2V0TWV0YVZhbHVlKCdkYWdfaWQnKTtcbmNvbnN0IGV4ZWN1dGlvbkRhdGUgPSBnZXRNZXRhVmFsdWUoJ2V4ZWN1dGlvbl9kYXRlJyk7XG5jb25zdCBkYWdSdW5JZCA9IGdldE1ldGFWYWx1ZSgnZGFnX3J1bl9pZCcpO1xuY29uc3QgYXJyYW5nZSA9IGdldE1ldGFWYWx1ZSgnYXJyYW5nZScpO1xuY29uc3QgdGFza0luc3RhbmNlc1VybCA9IGdldE1ldGFWYWx1ZSgndGFza19pbnN0YW5jZXNfdXJsJyk7XG5jb25zdCBpc1NjaGVkdWxlclJ1bm5pbmcgPSBnZXRNZXRhVmFsdWUoJ2lzX3NjaGVkdWxlcl9ydW5uaW5nJyk7IC8vIFRoaXMgbWFwcyB0aGUgYWN0dWFsIHRhc2tJZCB0byB0aGUgY3VycmVudCBncmFwaCBub2RlIGlkIHRoYXQgY29udGFpbnMgdGhlIHRhc2tcbi8vIChiZWNhdXNlIHRhc2tzIG1heSBiZSBncm91cGVkIGludG8gYSBncm91cCBub2RlKVxuXG5jb25zdCBtYXBUYXNrVG9Ob2RlID0gbmV3IE1hcCgpOyAvLyBCZWxvdyB2YXJpYWJsZXMgYXJlIGJlaW5nIHVzZWQgaW4gZGFnLmpzXG5cbmNvbnN0IGdldFRhc2tJbnN0YW5jZVVSTCA9IGAke3Rhc2tJbnN0YW5jZXNVcmx9P2RhZ19pZD0ke2VuY29kZVVSSUNvbXBvbmVudChkYWdJZCl9JmV4ZWN1dGlvbl9kYXRlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGV4ZWN1dGlvbkRhdGUpfWA7XG5jb25zdCBkdXJhdGlvbiA9IDUwMDtcbmNvbnN0IHN0YXRlRm9jdXNNYXAgPSB7XG4gIHN1Y2Nlc3M6IGZhbHNlLFxuICBydW5uaW5nOiBmYWxzZSxcbiAgZmFpbGVkOiBmYWxzZSxcbiAgc2tpcHBlZDogZmFsc2UsXG4gIHVwc3RyZWFtX2ZhaWxlZDogZmFsc2UsXG4gIHVwX2Zvcl9yZXNjaGVkdWxlOiBmYWxzZSxcbiAgdXBfZm9yX3JldHJ5OiBmYWxzZSxcbiAgcXVldWVkOiBmYWxzZSxcbiAgZGVmZXJyZWQ6IGZhbHNlLFxuICBub19zdGF0dXM6IGZhbHNlXG59O1xuXG5jb25zdCBjaGVja1J1blN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBzdGF0ZXMgPSBPYmplY3QudmFsdWVzKHRhc2tJbnN0YW5jZXMpLm1hcCh0aSA9PiB0aS5zdGF0ZSk7XG4gIHJldHVybiAhc3RhdGVzLnNvbWUoc3RhdGUgPT4gWydzdWNjZXNzJywgJ2ZhaWxlZCcsICd1cHN0cmVhbV9mYWlsZWQnLCAnc2tpcHBlZCcsICdyZW1vdmVkJ10uaW5kZXhPZihzdGF0ZSkgPT09IC0xKTtcbn07XG5cbmNvbnN0IHRhc2tUaXAgPSBkMy50aXAoKS5hdHRyKCdjbGFzcycsICd0b29sdGlwIGQzLXRpcCcpLmh0bWwodG9vbFRpcEh0bWwgPT4gdG9vbFRpcEh0bWwpOyAvLyBQcmVwYXJhdGlvbiBvZiBEYWdyZUQzIGRhdGEgc3RydWN0dXJlc1xuLy8gXCJjb21wb3VuZFwiIGlzIHNldCB0byB0cnVlIHRvIG1ha2UgdXNlIG9mIGNsdXN0ZXJzIHRvIGRpc3BsYXkgVGFza0dyb3VwLlxuXG5jb25zdCBnID0gbmV3IGRhZ3JlRDMuZ3JhcGhsaWIuR3JhcGgoe1xuICBjb21wb3VuZDogdHJ1ZVxufSkuc2V0R3JhcGgoe1xuICBub2Rlc2VwOiAzMCxcbiAgcmFua3NlcDogMTUsXG4gIHJhbmtkaXI6IGFycmFuZ2Vcbn0pLnNldERlZmF1bHRFZGdlTGFiZWwoKCkgPT4gKHtcbiAgbGluZUludGVycG9sYXRlOiAnYmFzaXMnXG59KSk7XG5jb25zdCByZW5kZXIgPSBkYWdyZUQzLnJlbmRlcigpO1xuY29uc3Qgc3ZnID0gZDMuc2VsZWN0KCcjZ3JhcGgtc3ZnJyk7XG5sZXQgaW5uZXJTdmcgPSBkMy5zZWxlY3QoJyNncmFwaC1zdmcgZycpOyAvLyBXZSBtb2RpZnkgdGhlIGxhYmVsIG9mIHRhc2sgbWFwIG5vZGVzIHRvIGluY2x1ZGUgdGhlIGJyYWNrZXRzIGFuZCBhIGNvdW50IG9mIG1hcHBlZCB0YXNrc1xuLy8gcmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBub2RlIGlzIGNoYW5nZWRcblxuY29uc3QgdXBkYXRlTm9kZUxhYmVscyA9IChub2RlLCBpbnN0YW5jZXMpID0+IHtcbiAgbGV0IGhhdmVMYWJlbHNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCB7XG4gICAgbGFiZWxcbiAgfSA9IG5vZGUudmFsdWU7IC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgY291bnQgb2YgbWFwcGVkIGluc3RhbmNlc1xuXG4gIGlmICh0YXNrc1tub2RlLmlkXSAmJiB0YXNrc1tub2RlLmlkXS5pc19tYXBwZWQpIHtcbiAgICBjb25zdCBjb3VudCA9IGluc3RhbmNlc1tub2RlLmlkXSAmJiBpbnN0YW5jZXNbbm9kZS5pZF0ubWFwcGVkX3N0YXRlcyA/IGluc3RhbmNlc1tub2RlLmlkXS5tYXBwZWRfc3RhdGVzLmxlbmd0aCA6ICcgJztcbiAgICBsYWJlbCA9IGAke25vZGUuaWR9IFske2NvdW50fV1gO1xuICB9XG5cbiAgaWYgKGcubm9kZShub2RlLmlkKSAmJiBnLm5vZGUobm9kZS5pZCkubGFiZWwgIT09IGxhYmVsKSB7XG4gICAgZy5ub2RlKG5vZGUuaWQpLmxhYmVsID0gbGFiZWw7XG4gICAgaGF2ZUxhYmVsc0NoYW5nZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggY2hpbGRyZW4gYW5kIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgY29uc3QgdXBkYXRlZE5vZGVzID0gbm9kZS5jaGlsZHJlbi5tYXAobiA9PiB1cGRhdGVOb2RlTGFiZWxzKG4sIGluc3RhbmNlcykpO1xuICAgIHJldHVybiB1cGRhdGVkTm9kZXMuc29tZShjaGFuZ2VkID0+IGNoYW5nZWQpO1xuICB9XG5cbiAgcmV0dXJuIGhhdmVMYWJlbHNDaGFuZ2VkO1xufTsgLy8gUmVtb3ZlIHRoZSBub2RlIHdpdGggdGhpcyBub2RlSWQgZnJvbSBnLlxuXG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZUlkKSB7XG4gIGlmIChnLmhhc05vZGUobm9kZUlkKSkge1xuICAgIGNvbnN0IG5vZGUgPSBnLm5vZGUobm9kZUlkKTtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBhbiBleHBhbmRlZCBncm91cCBub2RlLCByZW1vdmUgY2hpbGRyZW4gdG9vLlxuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZC5pZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnLnJlbW92ZU5vZGUobm9kZUlkKTtcbn0gLy8gQ29sbGFwc2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBncm91cCBub2RlLlxuXG5cbmZ1bmN0aW9uIGNvbGxhcHNlR3JvdXAobm9kZUlkLCBub2RlKSB7XG4gIC8vIFJlbW92ZSBjaGlsZHJlbiBub2Rlc1xuICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIHJlbW92ZU5vZGUoY2hpbGQuaWQpO1xuICB9KTsgLy8gTWFwIHRhc2sgdGhhdCBhcmUgdW5kZXIgdGhpcyBub2RlIHRvIHRoaXMgbm9kZSdzIGlkXG5cbiAgZ2V0Q2hpbGRyZW5JZHMobm9kZSkuZm9yRWFjaChjaGlsZElkID0+IG1hcFRhc2tUb05vZGUuc2V0KGNoaWxkSWQsIG5vZGVJZCkpO1xuICBub2RlID0gZy5ub2RlKG5vZGVJZCk7IC8vIFNldCBjaGlsZHJlbiBlZGdlcyBvbnRvIHRoZSBncm91cCBlZGdlXG5cbiAgZWRnZXMuZm9yRWFjaChlZGdlID0+IHtcbiAgICBjb25zdCBzb3VyY2VJZCA9IG1hcFRhc2tUb05vZGUuZ2V0KGVkZ2Uuc291cmNlX2lkKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IG1hcFRhc2tUb05vZGUuZ2V0KGVkZ2UudGFyZ2V0X2lkKTtcblxuICAgIGlmIChzb3VyY2VJZCAhPT0gdGFyZ2V0SWQgJiYgIWcuaGFzRWRnZShzb3VyY2VJZCwgdGFyZ2V0SWQpKSB7XG4gICAgICBnLnNldEVkZ2Uoc291cmNlSWQsIHRhcmdldElkLCB7XG4gICAgICAgIGN1cnZlOiBkMy5jdXJ2ZUJhc2lzLFxuICAgICAgICBhcnJvd2hlYWRDbGFzczogJ2Fycm93aGVhZCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGRyYXcoKTtcbiAgZm9jdXNHcm91cChub2RlSWQpO1xuICByZW1vdmVFeHBhbmRlZEdyb3VwKG5vZGVJZCwgbm9kZSk7XG59IC8vIFVwZGF0ZSB0aGUgcGFnZSB0byBzaG93IHRoZSBsYXRlc3QgREFHLlxuXG5cbmZ1bmN0aW9uIGRyYXcoKSB7XG4gIGlubmVyU3ZnLnJlbW92ZSgpO1xuICBpbm5lclN2ZyA9IHN2Zy5hcHBlbmQoJ2cnKTsgLy8gUnVuIHRoZSByZW5kZXJlci4gVGhpcyBpcyB3aGF0IGRyYXdzIHRoZSBmaW5hbCBncmFwaC5cblxuICBpbm5lclN2Zy5jYWxsKHJlbmRlciwgZyk7XG4gIGlubmVyU3ZnLmNhbGwodGFza1RpcCk7IC8vIFdoZW4gYW4gZXhwYW5kZWQgZ3JvdXAgaXMgY2xpY2tlZCwgY29sbGFwc2UgaXQuXG5cbiAgZDMuc2VsZWN0QWxsKCdnLmNsdXN0ZXInKS5vbignY2xpY2snLCBub2RlSWQgPT4ge1xuICAgIGlmIChkMy5ldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IGcubm9kZShub2RlSWQpO1xuICAgIGNvbGxhcHNlR3JvdXAobm9kZUlkLCBub2RlKTtcbiAgfSk7IC8vIFdoZW4gYSBub2RlIGlzIGNsaWNrZWQsIGFjdGlvbiBkZXBlbmRzIG9uIHRoZSBub2RlIHR5cGUuXG5cbiAgZDMuc2VsZWN0QWxsKCdnLm5vZGUnKS5vbignY2xpY2snLCBub2RlSWQgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnLm5vZGUobm9kZUlkKTtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMobm9kZS5jaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQSBncm91cCBub2RlXG4gICAgICBpZiAoZDMuZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXhwYW5kR3JvdXAobm9kZUlkLCBub2RlKTtcbiAgICAgIHVwZGF0ZU5vZGVMYWJlbHMobm9kZXMsIHRhc2tJbnN0YW5jZXMpO1xuICAgICAgZHJhdygpO1xuICAgICAgZm9jdXNHcm91cChub2RlSWQpO1xuICAgIH0gZWxzZSBpZiAobm9kZUlkIGluIHRhc2tJbnN0YW5jZXMpIHtcbiAgICAgIC8vIEEgdGFzayBub2RlXG4gICAgICBjb25zdCB0YXNrID0gdGFza3Nbbm9kZUlkXTtcbiAgICAgIGNvbnN0IHRyeU51bWJlciA9IHRhc2tJbnN0YW5jZXNbbm9kZUlkXS50cnlfbnVtYmVyIHx8IDA7XG4gICAgICBsZXQgbWFwcGVkU3RhdGVzID0gW107XG4gICAgICBpZiAodGFzay5pc19tYXBwZWQpIG1hcHBlZFN0YXRlcyA9IHRhc2tJbnN0YW5jZXNbbm9kZUlkXS5tYXBwZWRfc3RhdGVzO1xuICAgICAgY2FsbE1vZGFsKHtcbiAgICAgICAgdGFza0lkOiBub2RlSWQsXG4gICAgICAgIGV4ZWN1dGlvbkRhdGUsXG4gICAgICAgIGV4dHJhTGlua3M6IHRhc2suZXh0cmFfbGlua3MsXG4gICAgICAgIHRyeU51bWJlcixcbiAgICAgICAgaXNTdWJEYWc6IHRhc2sudGFza190eXBlID09PSAnU3ViRGFnT3BlcmF0b3InLFxuICAgICAgICBkYWdSdW5JZCxcbiAgICAgICAgbWFwSW5kZXg6IHRhc2subWFwX2luZGV4LFxuICAgICAgICBpc01hcHBlZDogdGFzay5pc19tYXBwZWQsXG4gICAgICAgIG1hcHBlZFN0YXRlc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZDMuc2VsZWN0QWxsKCdnLm5vZGUnKS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c292ZXIoZCkge1xuICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QnKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsICdoaWdobGlnaHQnKTtcbiAgICBoaWdobGlnaHROb2RlcyhnLnByZWRlY2Vzc29ycyhkKSk7XG4gICAgaGlnaGxpZ2h0Tm9kZXMoZy5zdWNjZXNzb3JzKGQpKTtcbiAgICBjb25zdCBhZGphY2VudE5vZGVOYW1lcyA9IFtkLCAuLi5nLnByZWRlY2Vzc29ycyhkKSwgLi4uZy5zdWNjZXNzb3JzKGQpXTtcbiAgICBkMy5zZWxlY3RBbGwoJ2cubm9kZXMgZy5ub2RlJykuZmlsdGVyKHggPT4gIWFkamFjZW50Tm9kZU5hbWVzLmluY2x1ZGVzKHgpKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsICdmYWRlJyk7XG4gICAgZDMuc2VsZWN0QWxsKCdnLmVkZ2VQYXRoJylbMF0uZm9yRWFjaCh4ID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IGcubm9kZUVkZ2VzKGQpLmluY2x1ZGVzKHguX19kYXRhX18pID8gJ2hpZ2hsaWdodCcgOiAnZmFkZSc7XG4gICAgICBkMy5zZWxlY3QoeCkuYXR0cignZGF0YS1oaWdobGlnaHQnLCB2YWwpO1xuICAgIH0pO1xuICAgIGQzLnNlbGVjdEFsbCgnZy5lZGdlTGFiZWwnKVswXS5mb3JFYWNoKHggPT4ge1xuICAgICAgaWYgKCFnLm5vZGVFZGdlcyhkKS5pbmNsdWRlcyh4Ll9fZGF0YV9fKSkge1xuICAgICAgICBkMy5zZWxlY3QoeCkuYXR0cignZGF0YS1oaWdobGlnaHQnLCAnZmFkZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgZDMuc2VsZWN0QWxsKCdnLm5vZGUnKS5vbignbW91c2VvdXQnLCBmdW5jdGlvbiBtb3VzZW91dChkKSB7XG4gICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgncmVjdCwgY2lyY2xlJykuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgICB1bkhpZ2hsaWdodE5vZGVzKGcucHJlZGVjZXNzb3JzKGQpKTtcbiAgICB1bkhpZ2hsaWdodE5vZGVzKGcuc3VjY2Vzc29ycyhkKSk7XG4gICAgZDMuc2VsZWN0QWxsKCdnLm5vZGUsIGcuZWRnZVBhdGgsIGcuZWRnZUxhYmVsJykuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShmb2N1c2VkR3JvdXBLZXkoZGFnSWQpKTtcbiAgfSk7XG4gIHVwZGF0ZU5vZGVzU3RhdGVzKHRhc2tJbnN0YW5jZXMpO1xuICBzZXRVcFpvb21TdXBwb3J0KCk7XG59XG5cbmxldCB6b29tID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0VXBab29tU3VwcG9ydCgpIHtcbiAgLy8gU2V0IHVwIHpvb20gc3VwcG9ydCBmb3IgR3JhcGhcbiAgem9vbSA9IGQzLmJlaGF2aW9yLnpvb20oKS5vbignem9vbScsICgpID0+IHtcbiAgICBpbm5lclN2Zy5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7ZDMuZXZlbnQudHJhbnNsYXRlfSlzY2FsZSgke2QzLmV2ZW50LnNjYWxlfSlgKTtcbiAgfSk7XG4gIHN2Zy5jYWxsKHpvb20pOyAvLyBDZW50ZXJpbmcgdGhlIERBRyBvbiBsb2FkXG4gIC8vIEdldCBEYWdyZSBHcmFwaCBkaW1lbnNpb25zXG5cbiAgY29uc3QgZ3JhcGhXaWR0aCA9IGcuZ3JhcGgoKS53aWR0aDtcbiAgY29uc3QgZ3JhcGhIZWlnaHQgPSBnLmdyYXBoKCkuaGVpZ2h0OyAvLyBHZXQgU1ZHIGRpbWVuc2lvbnNcblxuICBjb25zdCBwYWRkaW5nID0gODA7XG4gIGNvbnN0IHN2Z0JiID0gc3ZnLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgd2lkdGggPSBzdmdCYi53aWR0aCAtIHBhZGRpbmcgKiAyO1xuICBjb25zdCBoZWlnaHQgPSBzdmdCYi5oZWlnaHQgLSBwYWRkaW5nOyAvLyB3ZSBhcmUgbm90IGNlbnRlcmluZyB0aGUgZGFnIHZlcnRpY2FsbHlcbiAgLy8gQ2FsY3VsYXRlIGFwcGxpY2FibGUgc2NhbGUgZm9yIHpvb21cblxuICBjb25zdCB6b29tU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1pbih3aWR0aCAvIGdyYXBoV2lkdGgsIGhlaWdodCAvIGdyYXBoSGVpZ2h0KSwgMS41IC8vIGNhcCB6b29tIGxldmVsIHRvIDEuNSBzbyBub2RlcyBhcmUgbm90IHRvbyBsYXJnZVxuICApO1xuICB6b29tLnRyYW5zbGF0ZShbd2lkdGggLyAyIC0gZ3JhcGhXaWR0aCAqIHpvb21TY2FsZSAvIDIgKyBwYWRkaW5nLCBwYWRkaW5nXSk7XG4gIHpvb20uc2NhbGUoem9vbVNjYWxlKTtcbiAgem9vbS5ldmVudChpbm5lclN2Zyk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hsaWdodE5vZGVzKG5vZGVzKSB7XG4gIG5vZGVzLmZvckVhY2gobm9kZWlkID0+IHtcbiAgICBjb25zdCBteU5vZGUgPSBnLm5vZGUobm9kZWlkKS5lbGVtO1xuICAgIGQzLnNlbGVjdChteU5vZGUpLnNlbGVjdEFsbCgncmVjdCwgY2lyY2xlJykuYXR0cignZGF0YS1oaWdobGlnaHQnLCAnaGlnaGxpZ2h0Jyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bkhpZ2hsaWdodE5vZGVzKG5vZGVzKSB7XG4gIG5vZGVzLmZvckVhY2gobm9kZWlkID0+IHtcbiAgICBjb25zdCBteU5vZGUgPSBnLm5vZGUobm9kZWlkKS5lbGVtO1xuICAgIGQzLnNlbGVjdChteU5vZGUpLnNlbGVjdEFsbCgncmVjdCwgY2lyY2xlJykuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgfSk7XG59XG5cbmQzLnNlbGVjdEFsbCgnLmpzLXN0YXRlLWxlZ2VuZC1pdGVtJykub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlb3ZlcigpIHtcbiAgaWYgKCFzdGF0ZUlzU2V0KCkpIHtcbiAgICBjb25zdCBzdGF0ZSA9ICQodGhpcykuZGF0YSgnc3RhdGUnKTtcbiAgICBmb2N1c1N0YXRlKHN0YXRlKTtcbiAgfVxufSkub24oJ21vdXNlb3V0JywgKCkgPT4ge1xuICBpZiAoIXN0YXRlSXNTZXQoKSkge1xuICAgIGNsZWFyRm9jdXMoKTtcbiAgfVxufSk7XG5kMy5zZWxlY3RBbGwoJy5qcy1zdGF0ZS1sZWdlbmQtaXRlbScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIGNsaWNrKCkge1xuICBjb25zdCBzdGF0ZSA9ICQodGhpcykuZGF0YSgnc3RhdGUnKTtcbiAgY2xlYXJGb2N1cygpO1xuXG4gIGlmICghc3RhdGVGb2N1c01hcFtzdGF0ZV0pIHtcbiAgICBjb25zdCBjb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYm9yZGVyLWNvbG9yJyk7XG4gICAgZm9jdXNTdGF0ZShzdGF0ZSwgdGhpcywgY29sb3IpO1xuICAgIHNldEZvY3VzTWFwKHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRGb2N1c01hcCgpO1xuICAgIGQzLnNlbGVjdEFsbCgnLmpzLXN0YXRlLWxlZ2VuZC1pdGVtJykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBudWxsKTtcbiAgfVxufSk7IC8vIFJldHVybnMgdHJ1ZSBpZiBhIG5vZGUncyBpZCBvciBpdHMgY2hpbGRyZW4ncyBpZCBtYXRjaGVzIHNlYXJjaFRleHRcblxuZnVuY3Rpb24gbm9kZU1hdGNoZXMobm9kZUlkLCBzZWFyY2hUZXh0KSB7XG4gIGlmIChub2RlSWQuaW5kZXhPZihzZWFyY2hUZXh0KSA+IC0xKSByZXR1cm4gdHJ1ZTsgLy8gVGhlIG5vZGUncyBvd24gaWQgZG9lcyBub3QgbWF0Y2gsIGl0IG1heSBoYXZlIGNoaWxkcmVuIHRoYXQgbWF0Y2hcblxuICBjb25zdCBub2RlID0gZy5ub2RlKG5vZGVJZCk7XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuSWRzKG5vZGUpO1xuICAgIHJldHVybiAhIWNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaW5kZXhPZihzZWFyY2hUZXh0KSA+IC0xKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZDMuc2VsZWN0KCcjc2VhcmNoYm94Jykub24oJ2tleXVwJywgKCkgPT4ge1xuICBjb25zdCBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlYXJjaGJveCcpLnZhbHVlO1xuICBpZiAocyA9PT0gJycpIHJldHVybjtcbiAgbGV0IG1hdGNoID0gbnVsbDtcblxuICBpZiAoc3RhdGVJc1NldCgpKSB7XG4gICAgY2xlYXJGb2N1cygpO1xuICAgIHNldEZvY3VzTWFwKCk7XG4gIH1cblxuICBkMy5zZWxlY3RBbGwoJ2cubm9kZXMgZy5ub2RlJykuZmlsdGVyKGZ1bmN0aW9uIGhpZ2hsaWdodChkKSB7XG4gICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICBkMy5zZWxlY3RBbGwoJ2cuZWRnZVBhdGhzLCBnLmVkZ2VMYWJlbCcpLmF0dHIoJ2RhdGEtaGlnaGxpZ2h0JywgbnVsbCk7XG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDMuc2VsZWN0QWxsKCdnLmVkZ2VQYXRocywgZy5lZGdlTGFiZWwnKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsICdmYWRlJyk7XG5cbiAgICAgIGlmIChub2RlTWF0Y2hlcyhkLCBzKSkge1xuICAgICAgICBpZiAoIW1hdGNoKSBtYXRjaCA9IHRoaXM7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2RhdGEtaGlnaGxpZ2h0JywgJ2ZhZGUnKTtcbiAgICAgIH1cbiAgICB9IC8vIFdlIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgcmV0dXJuZWQgcmVzdWx0cyBmcm9tIGZpbHRlclxuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7IC8vIFRoaXMgbW92ZXMgdGhlIG1hdGNoZWQgbm9kZSB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFwaCBhcmVhXG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZDMudHJhbnNmb3JtKGQzLnNlbGVjdChtYXRjaCkuYXR0cigndHJhbnNmb3JtJykpO1xuICAgIGNvbnN0IHN2Z0JiID0gc3ZnLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlID0gW3N2Z0JiLndpZHRoIC8gMiAtIHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sIHN2Z0JiLmhlaWdodCAvIDIgLSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdXTtcbiAgICB0cmFuc2Zvcm0uc2NhbGUgPSBbMSwgMV07XG5cbiAgICBpZiAoem9vbSAhPSBudWxsKSB7XG4gICAgICB6b29tLnRyYW5zbGF0ZSh0cmFuc2Zvcm0udHJhbnNsYXRlKTtcbiAgICAgIHpvb20uc2NhbGUoMSk7XG4gICAgICB6b29tLmV2ZW50KGlubmVyU3ZnKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGVhckZvY3VzKCkge1xuICBkMy5zZWxlY3RBbGwoJ2cubm9kZSwgZy5lZGdlUGF0aHMsIGcuZWRnZUxhYmVsJykuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZm9jdXNlZEdyb3VwS2V5KGRhZ0lkKSk7XG59XG5cbmZ1bmN0aW9uIGZvY3VzU3RhdGUoc3RhdGUsIG5vZGUsIGNvbG9yKSB7XG4gIGQzLnNlbGVjdEFsbCgnZy5ub2RlLCBnLmVkZ2VQYXRocywgZy5lZGdlTGFiZWwnKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsICdmYWRlJyk7XG4gIGQzLnNlbGVjdEFsbChgZy5ub2RlLiR7c3RhdGV9YCkuYXR0cignZGF0YS1oaWdobGlnaHQnLCBudWxsKTtcbiAgZDMuc2VsZWN0QWxsKGBnLm5vZGUuJHtzdGF0ZX0gcmVjdGApLmF0dHIoJ2RhdGEtaGlnaGxpZ2h0JywgbnVsbCk7XG4gIGQzLnNlbGVjdChub2RlKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGNvbG9yKTtcbn1cblxuZnVuY3Rpb24gc2V0Rm9jdXNNYXAoc3RhdGUpIHtcbiAgT2JqZWN0LmtleXMoc3RhdGVGb2N1c01hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlRm9jdXNNYXAsIGtleSkpIHtcbiAgICAgIHN0YXRlRm9jdXNNYXBba2V5XSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICBzdGF0ZUZvY3VzTWFwW3N0YXRlXSA9IHRydWU7XG4gIH1cbn1cblxuY29uc3Qgc3RhdGVJc1NldCA9ICgpID0+ICEhT2JqZWN0LmtleXMoc3RhdGVGb2N1c01hcCkuZmluZChrZXkgPT4gc3RhdGVGb2N1c01hcFtrZXldKTtcblxubGV0IHJlZnJlc2hJbnRlcnZhbDtcblxuZnVuY3Rpb24gc3RhcnRPclN0b3BSZWZyZXNoKCkge1xuICBpZiAoJCgnI2F1dG9fcmVmcmVzaCcpLmlzKCc6Y2hlY2tlZCcpKSB7XG4gICAgcmVmcmVzaEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaGFuZGxlUmVmcmVzaCgpO1xuICAgIH0sIGF1dG9SZWZyZXNoSW50ZXJ2YWwgKiAxMDAwKTtcbiAgfSBlbHNlIHtcbiAgICBjbGVhckludGVydmFsKHJlZnJlc2hJbnRlcnZhbCk7XG4gIH1cbn0gLy8gcGF1c2UgYXV0b3JlZnJlc2ggd2hlbiB0aGUgcGFnZSBpcyBub3QgYWN0aXZlXG5cblxuY29uc3QgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgIGNsZWFySW50ZXJ2YWwocmVmcmVzaEludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0UmVmcmVzaCgpO1xuICB9XG59O1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG5sZXQgcHJldlRpcztcblxuZnVuY3Rpb24gaGFuZGxlUmVmcmVzaCgpIHtcbiAgJCgnI2xvYWRpbmctZG90cycpLmNzcygnZGlzcGxheScsICdpbmxpbmUtYmxvY2snKTtcbiAgJC5nZXQoZ2V0VGFza0luc3RhbmNlVVJMKS5kb25lKHRpcyA9PiB7XG4gICAgLy8gb25seSByZWZyZXNoIGlmIHRoZSBkYXRhIGhhcyBjaGFuZ2VkXG4gICAgaWYgKHByZXZUaXMgIT09IHRpcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWdsb2JhbC1hc3NpZ25cbiAgICAgIHRhc2tJbnN0YW5jZXMgPSBKU09OLnBhcnNlKHRpcyk7XG4gICAgICB1cGRhdGVOb2Rlc1N0YXRlcyh0YXNrSW5zdGFuY2VzKTsgLy8gT25seSByZWRyYXcgdGhlIGdyYXBoIGlmIGxhYmVscyBoYXZlIGNoYW5nZWRcblxuICAgICAgY29uc3QgaGF2ZUxhYmVsc0NoYW5nZWQgPSB1cGRhdGVOb2RlTGFiZWxzKG5vZGVzLCB0YXNrSW5zdGFuY2VzKTtcbiAgICAgIGlmIChoYXZlTGFiZWxzQ2hhbmdlZCkgZHJhdygpOyAvLyBlbmQgcmVmcmVzaCBpZiBhbGwgc3RhdGVzIGFyZSBmaW5hbFxuXG4gICAgICBjb25zdCBpc0ZpbmFsID0gY2hlY2tSdW5TdGF0ZSgpO1xuXG4gICAgICBpZiAoaXNGaW5hbCkge1xuICAgICAgICAkKCcjYXV0b19yZWZyZXNoJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZUaXMgPSB0aXM7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAkKCcjbG9hZGluZy1kb3RzJykuaGlkZSgpO1xuICAgIH0sIDUwMCk7XG4gICAgJCgnI2Vycm9yJykuaGlkZSgpO1xuICB9KS5mYWlsKChyZXNwb25zZSwgdGV4dFN0YXR1cywgZXJyKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSByZXNwb25zZS5yZXNwb25zZUpTT04gJiYgcmVzcG9uc2UucmVzcG9uc2VKU09OLmVycm9yIHx8ICdTb21ldGhpbmcgd2VudCB3cm9uZy4nO1xuICAgICQoJyNlcnJvcl9tc2cnKS50ZXh0KGAke3RleHRTdGF0dXN9OiAke2Vycn0gJHtkZXNjcmlwdGlvbn1gKTtcbiAgICAkKCcjZXJyb3InKS5zaG93KCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAkKCcjbG9hZGluZy1kb3RzJykuaGlkZSgpO1xuICAgIH0sIDUwMCk7XG4gICAgJCgnI2NoYXJ0X3NlY3Rpb24nKS5oaWRlKDEwMDApO1xuICAgICQoJyNkYXRhdGFibGVfc2VjdGlvbicpLmhpZGUoMTAwMCk7XG4gIH0pO1xufVxuXG4kKCcjYXV0b19yZWZyZXNoJykuY2hhbmdlKCgpID0+IHtcbiAgaWYgKCQoJyNhdXRvX3JlZnJlc2gnKS5pcygnOmNoZWNrZWQnKSkge1xuICAgIC8vIFJ1biBhbiBpbml0aWFsIHJlZnJlc2ggYmVmb3JlIHN0YXJ0aW5nIGludGVydmFsIGlmIG1hbnVhbGx5IHR1cm5lZCBvblxuICAgIGhhbmRsZVJlZnJlc2goKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZGlzYWJsZUF1dG9SZWZyZXNoJyk7XG4gIH0gZWxzZSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Rpc2FibGVBdXRvUmVmcmVzaCcsICd0cnVlJyk7XG4gIH1cblxuICBzdGFydE9yU3RvcFJlZnJlc2goKTtcbn0pO1xuXG5mdW5jdGlvbiBpbml0UmVmcmVzaCgpIHtcbiAgY29uc3QgaXNEaXNhYmxlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkaXNhYmxlQXV0b1JlZnJlc2gnKTtcbiAgY29uc3QgaXNGaW5hbCA9IGNoZWNrUnVuU3RhdGUoKTtcbiAgJCgnI2F1dG9fcmVmcmVzaCcpLnByb3AoJ2NoZWNrZWQnLCAhKGlzRGlzYWJsZWQgfHwgaXNGaW5hbCkgJiYgaXNTY2hlZHVsZXJSdW5uaW5nID09PSAnVHJ1ZScpO1xuICBzdGFydE9yU3RvcFJlZnJlc2goKTtcbiAgZDMuc2VsZWN0KCcjcmVmcmVzaF9idXR0b24nKS5vbignY2xpY2snLCAoKSA9PiBoYW5kbGVSZWZyZXNoKCkpO1xufSAvLyBHZW5lcmF0ZSB0b29sdGlwIGZvciBhIGdyb3VwIG5vZGVcblxuXG5mdW5jdGlvbiBncm91cFRvb2x0aXAobm9kZSwgdGlzKSB7XG4gIGNvbnN0IG51bU1hcCA9IGZpbmFsU3RhdGVzTWFwKCk7XG4gIGxldCBtaW5TdGFydDtcbiAgbGV0IG1heEVuZDtcbiAgZ2V0Q2hpbGRyZW5JZHMobm9kZSkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgaWYgKGNoaWxkIGluIHRpcykge1xuICAgICAgY29uc3QgdGkgPSB0aXNbY2hpbGRdO1xuXG4gICAgICBpZiAoIW1pblN0YXJ0IHx8IG1vbWVudCh0aS5zdGFydF9kYXRlKS5pc0JlZm9yZShtaW5TdGFydCkpIHtcbiAgICAgICAgbWluU3RhcnQgPSBtb21lbnQodGkuc3RhcnRfZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF4RW5kIHx8IG1vbWVudCh0aS5lbmRfZGF0ZSkuaXNBZnRlcihtYXhFbmQpKSB7XG4gICAgICAgIG1heEVuZCA9IG1vbWVudCh0aS5lbmRfZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXRlS2V5ID0gdGkuc3RhdGUgPT0gbnVsbCA/ICdub19zdGF0dXMnIDogdGkuc3RhdGU7XG4gICAgICBpZiAobnVtTWFwLmhhcyhzdGF0ZUtleSkpIG51bU1hcC5zZXQoc3RhdGVLZXksIG51bU1hcC5nZXQoc3RhdGVLZXkpICsgMSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZ3JvdXBEdXJhdGlvbiA9IGNvbnZlcnRTZWNzVG9IdW1hblJlYWRhYmxlKG1vbWVudChtYXhFbmQpLmRpZmYobWluU3RhcnQsICdzZWNvbmQnKSk7XG4gIGNvbnN0IHRvb2x0aXBUZXh0ID0gbm9kZS50b29sdGlwID8gYDxwPiR7bm9kZS50b29sdGlwfTwvcD5gIDogJyc7XG4gIGxldCB0dCA9IGBcbiAgICAke3Rvb2x0aXBUZXh0fVxuICAgIDxzdHJvbmc+RHVyYXRpb246PC9zdHJvbmc+ICR7Z3JvdXBEdXJhdGlvbn0gPGJyPjxicj5cbiAgYDtcbiAgbnVtTWFwLmZvckVhY2goKGtleSwgdmFsKSA9PiB7XG4gICAgaWYgKGtleSA+IDApIHtcbiAgICAgIHR0ICs9IGA8c3Ryb25nPiR7ZXNjYXBlSHRtbCh2YWwpfTo8L3N0cm9uZz4gJHtrZXl9IDxicj5gO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0dDtcbn0gLy8gQXNzaWduaW5nIGNzcyBjbGFzc2VzIGJhc2VkIG9uIHN0YXRlIHRvIG5vZGVzXG4vLyBJbml0aWF0aW5nIHRoZSB0b29sdGlwc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZU5vZGVzU3RhdGVzKHRpcykge1xuICBnLm5vZGVzKCkuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnLm5vZGUobm9kZUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3QgdGFza0lkID0gbm9kZUlkO1xuXG4gICAgaWYgKGVsZW0pIHtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBgbm9kZSBlbnRlciAke2dldE5vZGVTdGF0ZShub2RlSWQsIHRpcyl9YDtcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzZXMpO1xuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJywgJ3Rvb2x0aXAnKTtcblxuICAgICAgZWxlbS5vbm1vdXNlb3ZlciA9IGV2dCA9PiB7XG4gICAgICAgIGxldCB0dDtcblxuICAgICAgICBpZiAodGFza0lkIGluIHRpcykge1xuICAgICAgICAgIHR0ID0gdGlUb29sdGlwKHRpc1t0YXNrSWRdKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdHQgPSBncm91cFRvb2x0aXAobm9kZSwgdGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXNrSWQgaW4gdGFza3MpIHtcbiAgICAgICAgICB0dCA9IHRhc2tOb0luc3RhbmNlVG9vbHRpcCh0YXNrSWQsIHRhc2tzW3Rhc2tJZF0pO1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIGAke2NsYXNzZXN9IG5vdC1hbGxvd2VkYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHQpIHRhc2tUaXAuc2hvdyh0dCwgZXZ0LnRhcmdldCk7IC8vIHRhc2tUaXAgaXMgZGVmaW5lZCBpbiBncmFwaC5odG1sXG4gICAgICB9O1xuXG4gICAgICBlbGVtLm9ubW91c2VvdXQgPSB0YXNrVGlwLmhpZGU7XG4gICAgICBlbGVtLm9uY2xpY2sgPSB0YXNrVGlwLmhpZGU7XG4gICAgfVxuICB9KTtcbn0gLy8gUmV0dXJucyBsaXN0IG9mIGNoaWxkcmVuIGlkIG9mIHRoZSBnaXZlbiB0YXNrIGdyb3VwXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5JZHMoZ3JvdXApIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgT2JqZWN0LnZhbHVlcyhncm91cC5jaGlsZHJlbikuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlLmNoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vZGVcbiAgICAgIGNoaWxkcmVuLnB1c2godmFsdWUuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBncm91cFxuICAgICAgY29uc3Qgc3ViR3JvdXBDaGlsZHJlbiA9IGdldENoaWxkcmVuSWRzKHZhbHVlKTtcbiAgICAgIHN1Ykdyb3VwQ2hpbGRyZW4uZm9yRWFjaChpZCA9PiBjaGlsZHJlbi5wdXNoKGlkKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBSZXR1cm4gbGlzdCBvZiBhbGwgdGFzayBncm91cCBpZHMgaW4gdGhlIGdpdmVuIHRhc2sgZ3JvdXAgaW5jbHVkaW5nIHRoZSBnaXZlbiBncm91cCBpdHNlbGYuXG5cblxuZnVuY3Rpb24gZ2V0QWxsR3JvdXBJZHMoZ3JvdXApIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbZ3JvdXAuaWRdO1xuICBPYmplY3QuZW50cmllcyhncm91cC5jaGlsZHJlbikuZm9yRWFjaCgoWywgdmFsXSkgPT4ge1xuICAgIGlmICh2YWwuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZ3JvdXBcbiAgICAgIGNvbnN0IHN1Ykdyb3VwQ2hpbGRyZW4gPSBnZXRBbGxHcm91cElkcyh2YWwpO1xuICAgICAgc3ViR3JvdXBDaGlsZHJlbi5mb3JFYWNoKGlkID0+IGNoaWxkcmVuLnB1c2goaWQpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSBub2RlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiBpdHMgdGFza2luc3RhbmNlIG9yIHRoYXQgb2YgaXRzXG4vLyBjaGlsZHJlbiBpZiBpdCdzIGEgZ3JvdXAgbm9kZVxuXG5cbmZ1bmN0aW9uIGdldE5vZGVTdGF0ZShub2RlSWQsIHRpcykge1xuICBjb25zdCBub2RlID0gZy5ub2RlKG5vZGVJZCk7XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChub2RlSWQgaW4gdGlzKSB7XG4gICAgICByZXR1cm4gdGlzW25vZGVJZF0uc3RhdGUgfHwgJ25vX3N0YXR1cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdub19zdGF0dXMnO1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbklkcyhub2RlKTtcbiAgY29uc3QgY2hpbGRyZW5TdGF0ZXMgPSBuZXcgU2V0KCk7XG4gIGNoaWxkcmVuLmZvckVhY2godGFza0lkID0+IHtcbiAgICBpZiAodGFza0lkIGluIHRpcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZVxuICAgICAgfSA9IHRpc1t0YXNrSWRdO1xuICAgICAgY2hpbGRyZW5TdGF0ZXMuYWRkKHN0YXRlID09IG51bGwgPyAnbm9fc3RhdHVzJyA6IHN0YXRlKTtcbiAgICB9XG4gIH0pOyAvLyBJbiB0aGlzIG9yZGVyLCBpZiBhbnkgb2YgdGhlc2Ugc3RhdGVzIGFwcGVhcmVkIGluIGNoaWxkcmVuU3RhdGVzLCByZXR1cm4gaXQgYXNcbiAgLy8gdGhlIGdyb3VwIHN0YXRlLlxuXG4gIGNvbnN0IHByaW9yaXR5ID0gWydmYWlsZWQnLCAndXBzdHJlYW1fZmFpbGVkJywgJ3VwX2Zvcl9yZXRyeScsICd1cF9mb3JfcmVzY2hlZHVsZScsICdxdWV1ZWQnLCAnc2NoZWR1bGVkJywgJ3NlbnNpbmcnLCAncnVubmluZycsICdzaHV0ZG93bicsICdyZXN0YXJ0aW5nJywgJ3JlbW92ZWQnLCAnbm9fc3RhdHVzJywgJ3N1Y2Nlc3MnLCAnc2tpcHBlZCddO1xuICByZXR1cm4gcHJpb3JpdHkuZmluZChzdGF0ZSA9PiBjaGlsZHJlblN0YXRlcy5oYXMoc3RhdGUpKSB8fCAnbm9fc3RhdHVzJztcbn0gLy8gUmV0dXJucyB0aGUga2V5IHVzZWQgdG8gc3RvcmUgZXhwYW5kZWQgdGFzayBncm91cCBpZHMgaW4gbG9jYWxTdG9yYWdlXG5cblxuZnVuY3Rpb24gZXhwYW5kZWRHcm91cHNLZXkoKSB7XG4gIHJldHVybiBgZXhwYW5kZWRHcm91cHNfJHtkYWdJZH1gO1xufSAvLyBSZXR1cm5zIHRoZSBrZXkgdXNlZCB0byBzdG9yZSB0aGUgZm9jdXNlZCB0YXNrIGdyb3VwIGlkIGluIGxvY2FsU3RvcmFnZVxuXG5cbmZ1bmN0aW9uIGZvY3VzZWRHcm91cEtleSgpIHtcbiAgcmV0dXJuIGBmb2N1c2VkX2dyb3VwXyR7ZGFnSWR9YDtcbn0gLy8gRm9jdXMgdGhlIGdyYXBoIG9uIHRoZSBleHBhbmRlZC9jb2xsYXBzZWQgbm9kZVxuXG5cbmZ1bmN0aW9uIGZvY3VzR3JvdXAobm9kZUlkKSB7XG4gIGlmIChub2RlSWQgIT0gbnVsbCAmJiB6b29tICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICB4XG4gICAgfSA9IGcubm9kZShub2RlSWQpOyAvLyBUaGlzIGlzIHRoZSB0b3RhbCBjYW52YXMgc2l6ZS5cblxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHN2Zy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFRoaXMgaXMgdGhlIHNpemUgb2YgdGhlIG5vZGUgb3IgdGhlIGNsdXN0ZXIgKGkuZS4gZ3JvdXApXG5cbiAgICBsZXQgcmVjdCA9IGQzLnNlbGVjdEFsbCgnZy5ub2RlJykuZmlsdGVyKG4gPT4gbiA9PT0gbm9kZUlkKS5zZWxlY3QoJ3JlY3QnKTtcbiAgICBpZiAocmVjdC5lbXB0eSgpKSByZWN0ID0gZDMuc2VsZWN0QWxsKCdnLmNsdXN0ZXInKS5maWx0ZXIobiA9PiBuID09PSBub2RlSWQpLnNlbGVjdCgncmVjdCcpOyAvLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZ2V0IG5vZGVXaWR0aCBhbmQgbm9kZUhlaWdodCA/XG5cbiAgICBjb25zdCBbbm9kZVdpZHRoLCBub2RlSGVpZ2h0XSA9IFtyZWN0WzBdWzBdLmF0dHJpYnV0ZXMud2lkdGgudmFsdWUsIHJlY3RbMF1bMF0uYXR0cmlidXRlcy5oZWlnaHQudmFsdWVdOyAvLyBDYWxjdWxhdGUgem9vbSBzY2FsZSB0byBmaWxsIG1vc3Qgb2YgdGhlIGNhbnZhcyB3aXRoIHRoZSBub2RlL2NsdXN0ZXIgaW4gZm9jdXMuXG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKE1hdGgubWluKHdpZHRoIC8gbm9kZVdpZHRoLCBoZWlnaHQgLyBub2RlSGVpZ2h0KSwgMS41IC8vIGNhcCB6b29tIGxldmVsIHRvIDEuNSBzbyBub2RlcyBhcmUgbm90IHRvbyBsYXJnZVxuICAgICkgKiAwLjk7IC8vIGRlbHRhWSBvZiA1IGtlZXBzIHRoZSB6b29tIGF0IHRoZSB0b3Agb2YgdGhlIHZpZXcgYnV0IHdpdGggYSBzbGlnaHQgbWFyZ2luXG5cbiAgICBjb25zdCBbZGVsdGFYLCBkZWx0YVldID0gW3dpZHRoIC8gMiAtIHggKiBzY2FsZSwgNV07XG4gICAgem9vbS50cmFuc2xhdGUoW2RlbHRhWCwgZGVsdGFZXSk7XG4gICAgem9vbS5zY2FsZShzY2FsZSk7XG4gICAgem9vbS5ldmVudChpbm5lclN2Zy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5ldyBTZXQoZy5jaGlsZHJlbihub2RlSWQpKTsgLy8gU2V0IGRhdGEgYXR0ciB0byBoaWdobGlnaHQgdGhlIGZvY3VzZWQgZ3JvdXAgKHZpYSBDU1MpLlxuXG4gICAgZDMuc2VsZWN0QWxsKCdnLm5vZGVzIGcubm9kZScpLmZvckVhY2goZnVuY3Rpb24gY3NzSGlnaGxpZ2h0KGQpIHtcbiAgICAgIGlmIChkID09PSBub2RlSWQgfHwgY2hpbGRyZW4uaGFzKGQpKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdkYXRhLWhpZ2hsaWdodCcsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2RhdGEtaGlnaGxpZ2h0JywgJ2ZhZGUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShmb2N1c2VkR3JvdXBLZXkoZGFnSWQpLCBub2RlSWQpO1xuICB9XG59IC8vIEV4cGFuZHMgYSBncm91cCBub2RlXG5cblxuZnVuY3Rpb24gZXhwYW5kR3JvdXAobm9kZUlkLCBub2RlKSB7XG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCh2YWwgPT4ge1xuICAgIC8vIFNldCBjaGlsZHJlbiBub2Rlc1xuICAgIGcuc2V0Tm9kZSh2YWwuaWQsIHZhbC52YWx1ZSk7XG4gICAgbWFwVGFza1RvTm9kZS5zZXQodmFsLmlkLCB2YWwuaWQpO1xuICAgIGcubm9kZSh2YWwuaWQpLmlkID0gdmFsLmlkO1xuXG4gICAgaWYgKHZhbC5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTZXQgY2hpbGRyZW4gYXR0cmlidXRlIHNvIHRoYXQgdGhlIGdyb3VwIGNhbiBiZSBleHBhbmRlZCBsYXRlciB3aGVuIG5lZWRlZC5cbiAgICAgIGNvbnN0IGdyb3VwTm9kZSA9IGcubm9kZSh2YWwuaWQpO1xuICAgICAgZ3JvdXBOb2RlLmNoaWxkcmVuID0gdmFsLmNoaWxkcmVuOyAvLyBNYXAgdGFzayB0aGF0IGFyZSB1bmRlciB0aGlzIG5vZGUgdG8gdGhpcyBub2RlJ3MgaWRcblxuICAgICAgZ2V0Q2hpbGRyZW5JZHModmFsKS5mb3JFYWNoKGNoaWxkSWQgPT4gbWFwVGFza1RvTm9kZS5zZXQoY2hpbGRJZCwgdmFsLmlkKSk7XG4gICAgfSAvLyBPbmx5IGNhbGwgc2V0UGFyZW50IGlmIG5vZGUgaXMgbm90IHRoZSByb290IG5vZGUuXG5cblxuICAgIGlmIChub2RlSWQgIT0gbnVsbCkgZy5zZXRQYXJlbnQodmFsLmlkLCBub2RlSWQpO1xuICB9KTsgLy8gQWRkIGVkZ2VzXG5cbiAgZWRnZXMuZm9yRWFjaChlZGdlID0+IHtcbiAgICBjb25zdCBzb3VyY2VJZCA9IG1hcFRhc2tUb05vZGUuZ2V0KGVkZ2Uuc291cmNlX2lkKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IG1hcFRhc2tUb05vZGUuZ2V0KGVkZ2UudGFyZ2V0X2lkKTtcblxuICAgIGlmIChzb3VyY2VJZCAhPT0gdGFyZ2V0SWQgJiYgIWcuaGFzRWRnZShzb3VyY2VJZCwgdGFyZ2V0SWQpICYmIHNvdXJjZUlkICYmIHRhcmdldElkKSB7XG4gICAgICBnLnNldEVkZ2Uoc291cmNlSWQsIHRhcmdldElkLCB7XG4gICAgICAgIGN1cnZlOiBkMy5jdXJ2ZUJhc2lzLFxuICAgICAgICBhcnJvd2hlYWRDbGFzczogJ2Fycm93aGVhZCcsXG4gICAgICAgIGxhYmVsOiBlZGdlLmxhYmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBnLmVkZ2VzKCkuZm9yRWFjaChlZGdlID0+IHtcbiAgICAvLyBSZW1vdmUgZWRnZXMgdGhhdCB3ZXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXhwYW5kZWQgZ3JvdXAgbm9kZS4uXG4gICAgaWYgKG5vZGVJZCA9PT0gZWRnZS52IHx8IG5vZGVJZCA9PT0gZWRnZS53KSB7XG4gICAgICBnLnJlbW92ZUVkZ2UoZWRnZS52LCBlZGdlLncpO1xuICAgIH1cbiAgfSk7XG4gIHNhdmVFeHBhbmRlZEdyb3VwKG5vZGVJZCk7XG59XG5cbmZ1bmN0aW9uIGdldFNhdmVkR3JvdXBzKCkge1xuICBsZXQgZXhwYW5kZWRHcm91cHM7XG5cbiAgdHJ5IHtcbiAgICBleHBhbmRlZEdyb3VwcyA9IG5ldyBTZXQoSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShleHBhbmRlZEdyb3Vwc0tleShkYWdJZCkpKSk7XG4gIH0gY2F0Y2gge1xuICAgIGV4cGFuZGVkR3JvdXBzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkR3JvdXBzO1xufSAvLyBDbGVhbiB1cCBpbnZhbGlkIGdyb3VwX2lkcyBmcm9tIHNhdmVkX2dyb3VwX2lkcyAoZS5nLiBkdWUgdG8gREFHIGNoYW5nZXMpXG5cblxuZnVuY3Rpb24gcHJ1bmVJbnZhbGlkU2F2ZWRHcm91cElkcygpIHtcbiAgLy8gQWxsIHRoZSBncm91cElkcyBpbiB0aGUgd2hvbGUgREFHXG4gIGNvbnN0IGFsbEdyb3VwSWRzID0gbmV3IFNldChnZXRBbGxHcm91cElkcyhub2RlcykpO1xuICBsZXQgZXhwYW5kZWRHcm91cHMgPSBnZXRTYXZlZEdyb3VwcyhkYWdJZCk7XG4gIGV4cGFuZGVkR3JvdXBzID0gQXJyYXkuZnJvbShleHBhbmRlZEdyb3VwcykuZmlsdGVyKGdyb3VwSWQgPT4gYWxsR3JvdXBJZHMuaGFzKGdyb3VwSWQpKTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZXhwYW5kZWRHcm91cHNLZXkoZGFnSWQpLCBKU09OLnN0cmluZ2lmeShleHBhbmRlZEdyb3VwcykpO1xufSAvLyBSZW1lbWJlciB0aGUgZXhwYW5kZWQgZ3JvdXBzIGluIGxvY2FsIHN0b3JhZ2Ugc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxuLy8gdG8gcmVzdG9yZSB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGFzayBncm91cHMuXG5cblxuZnVuY3Rpb24gc2F2ZUV4cGFuZGVkR3JvdXAobm9kZUlkKSB7XG4gIC8vIGV4cGFuZGVkR3JvdXBzIGlzIGEgU2V0XG4gIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gZ2V0U2F2ZWRHcm91cHMoZGFnSWQpO1xuICBleHBhbmRlZEdyb3Vwcy5hZGQobm9kZUlkKTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZXhwYW5kZWRHcm91cHNLZXkoZGFnSWQpLCBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGV4cGFuZGVkR3JvdXBzKSkpO1xufSAvLyBSZW1vdmUgdGhlIG5vZGVJZCBmcm9tIHRoZSBleHBhbmRlZCBzdGF0ZVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUV4cGFuZGVkR3JvdXAobm9kZUlkLCBub2RlKSB7XG4gIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gZ2V0U2F2ZWRHcm91cHMoZGFnSWQpO1xuICBjb25zdCBjaGlsZEdyb3VwSWRzID0gZ2V0QWxsR3JvdXBJZHMobm9kZSk7XG4gIGNoaWxkR3JvdXBJZHMuZm9yRWFjaChjaGlsZElkID0+IGV4cGFuZGVkR3JvdXBzLmRlbGV0ZShjaGlsZElkKSk7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGV4cGFuZGVkR3JvdXBzS2V5KGRhZ0lkKSwgSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShleHBhbmRlZEdyb3VwcykpKTtcbn0gLy8gUmVzdG9yZSBwcmV2aW91c2x5IGV4cGFuZGVkIHRhc2sgZ3JvdXBzXG5cblxuZnVuY3Rpb24gZXhwYW5kU2F2ZWRHcm91cHMoZXhwYW5kZWRHcm91cHMsIG5vZGUpIHtcbiAgaWYgKG5vZGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICBpZiAoZXhwYW5kZWRHcm91cHMuaGFzKGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgIGV4cGFuZEdyb3VwKGNoaWxkTm9kZS5pZCwgZy5ub2RlKGNoaWxkTm9kZS5pZCkpO1xuICAgICAgZXhwYW5kU2F2ZWRHcm91cHMoZXhwYW5kZWRHcm91cHMsIGNoaWxkTm9kZSk7XG4gICAgfVxuICB9KTtcbn1cblxucHJ1bmVJbnZhbGlkU2F2ZWRHcm91cElkcygpO1xuY29uc3QgZm9jdXNOb2RlSWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShmb2N1c2VkR3JvdXBLZXkoZGFnSWQpKTtcbmNvbnN0IGV4cGFuZGVkR3JvdXBzID0gZ2V0U2F2ZWRHcm91cHMoZGFnSWQpOyAvLyBBbHdheXMgZXhwYW5kIHRoZSByb290IG5vZGVcblxuZXhwYW5kR3JvdXAobnVsbCwgbm9kZXMpOyAvLyBFeHBhbmQgdGhlIG5vZGUgdGhhdCB3ZXJlIHByZXZpb3VzbHkgZXhwYW5kZWRcblxuZXhwYW5kU2F2ZWRHcm91cHMoZXhwYW5kZWRHcm91cHMsIG5vZGVzKTsgLy8gRHJhdyBvbmNlIGFmdGVyIGFsbCBncm91cHMgaGF2ZSBiZWVuIGV4cGFuZGVkXG5cbnVwZGF0ZU5vZGVMYWJlbHMobm9kZXMsIHRhc2tJbnN0YW5jZXMpO1xuZHJhdygpOyAvLyBSZXN0b3JlIGZvY3VzIChpZiBhdmFpbGFibGUpXG5cbmlmIChnLmhhc05vZGUoZm9jdXNOb2RlSWQpKSB7XG4gIGZvY3VzR3JvdXAoZm9jdXNOb2RlSWQpO1xufVxuXG5pbml0UmVmcmVzaCgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./static/js/graph.js\n");

/***/ }),

/***/ "./static/js/main.js":
/*!***************************!*\
  !*** ./static/js/main.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertSecsToHumanReadable\": () => (/* binding */ convertSecsToHumanReadable),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml)\n/* harmony export */ });\n/* harmony import */ var _datetime_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datetime_utils */ \"./static/js/datetime_utils.js\");\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* global $, moment, Airflow, window, localStorage, document, hostName, csrfToken, CustomEvent */\n\nwindow.isoDateToTimeEl = _datetime_utils__WEBPACK_IMPORTED_MODULE_0__.isoDateToTimeEl;\n/*\n We pull moment in via a webpack entrypoint rather than import\n so that we don't put it in more than a single .js file.\n This \"exports\" it to be globally available.\n*/\n\nwindow.moment = Airflow.moment;\n\nfunction displayTime() {\n  const now = moment();\n  $('#clock').attr('datetime', now.format(_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.dateTimeAttrFormat)).html(`${now.format('HH:mm')} <strong>${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.formatTimezone)(now)}</strong>`);\n}\n\nfunction changeDisplayedTimezone(tz) {\n  localStorage.setItem('selected-timezone', tz); // dispatch an event that React can listen for\n\n  const event = new CustomEvent(_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.TimezoneEvent, {\n    detail: tz\n  });\n  document.dispatchEvent(event);\n  (0,_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.setDisplayedTimezone)(tz);\n  displayTime();\n  $('body').trigger({\n    type: 'airflow.timezone-change',\n    timezone: tz\n  });\n}\n\nconst el = document.createElement('span');\nfunction escapeHtml(text) {\n  el.textContent = text;\n  return el.innerHTML;\n}\nwindow.escapeHtml = escapeHtml;\nfunction convertSecsToHumanReadable(seconds) {\n  const oriSeconds = seconds;\n  const floatingPart = oriSeconds - Math.floor(oriSeconds);\n  seconds = Math.floor(seconds);\n  const secondsPerHour = 60 * 60;\n  const secondsPerMinute = 60;\n  const hours = Math.floor(seconds / secondsPerHour);\n  seconds -= hours * secondsPerHour;\n  const minutes = Math.floor(seconds / secondsPerMinute);\n  seconds -= minutes * secondsPerMinute;\n  let readableFormat = '';\n\n  if (hours > 0) {\n    readableFormat += `${hours}Hours `;\n  }\n\n  if (minutes > 0) {\n    readableFormat += `${minutes}Min `;\n  }\n\n  if (seconds + floatingPart > 0) {\n    if (Math.floor(oriSeconds) === oriSeconds) {\n      readableFormat += `${seconds}Sec`;\n    } else {\n      seconds += floatingPart;\n      readableFormat += `${seconds.toFixed(3)}Sec`;\n    }\n  }\n\n  return readableFormat;\n}\nwindow.convertSecsToHumanReadable = convertSecsToHumanReadable;\n\nfunction postAsForm(url, parameters) {\n  const form = $('<form></form>');\n  form.attr('method', 'POST');\n  form.attr('action', url);\n  $.each(parameters || {}, (key, value) => {\n    const field = $('<input></input>');\n    field.attr('type', 'hidden');\n    field.attr('name', key);\n    field.attr('value', value);\n    form.append(field);\n  });\n  const field = $('<input></input>');\n  field.attr('type', 'hidden');\n  field.attr('name', 'csrf_token');\n  field.attr('value', csrfToken);\n  form.append(field); // The form needs to be a part of the document in order for us to be able\n  // to submit it.\n\n  $(document.body).append(form);\n  form.submit();\n}\n\nwindow.postAsForm = postAsForm;\n\nfunction initializeUITimezone() {\n  const local = moment.tz.guess();\n  const selectedTz = localStorage.getItem('selected-timezone');\n  const manualTz = localStorage.getItem('chosen-timezone');\n\n  function setManualTimezone(tz) {\n    localStorage.setItem('chosen-timezone', tz);\n\n    if (tz === local && tz === Airflow.serverTimezone) {\n      $('#timezone-manual').hide();\n      return;\n    }\n\n    $('#timezone-manual a').data('timezone', tz).text((0,_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.formatTimezone)(tz));\n    $('#timezone-manual').show();\n  }\n\n  if (manualTz) {\n    setManualTimezone(manualTz);\n  }\n\n  changeDisplayedTimezone(selectedTz || Airflow.defaultUITimezone);\n\n  if (Airflow.serverTimezone !== 'UTC') {\n    $('#timezone-server a').html(`${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.formatTimezone)(Airflow.serverTimezone)} <span class=\"label label-primary\">Server</span>`);\n    $('#timezone-server').show();\n  }\n\n  if (Airflow.serverTimezone !== local) {\n    $('#timezone-local a').attr('data-timezone', local).html(`${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_0__.formatTimezone)(local)} <span class=\"label label-info\">Local</span>`);\n  } else {\n    $('#timezone-local').hide();\n  }\n\n  $('a[data-timezone]').click(evt => {\n    changeDisplayedTimezone($(evt.currentTarget).data('timezone'));\n  });\n  $('#timezone-other').typeahead({\n    source: $(moment.tz.names().map(tzName => {\n      const category = tzName.split('/', 1)[0];\n      return {\n        category,\n        name: tzName.replace('_', ' '),\n        tzName\n      };\n    })),\n    showHintOnFocus: 'all',\n    showCategoryHeader: true,\n    items: 'all',\n\n    afterSelect(data) {\n      // Clear it for next time we open the pop-up\n      this.$element.val('');\n      setManualTimezone(data.tzName);\n      changeDisplayedTimezone(data.tzName); // We need to delay the close event to not be in the form handler,\n      // otherwise bootstrap ignores it, thinking it's caused by interaction on\n      // the <form>\n\n      setTimeout(() => {\n        document.activeElement.blur(); // Bug in typeahed, it thinks it's still shown!\n\n        this.shown = false;\n        this.focused = false;\n      }, 1);\n    }\n\n  });\n}\n\n$(document).ready(() => {\n  // custom redirect home\n  if (window.location.href.indexOf('home') === -1) document.getElementById('navbarId').href = '/';\n  initializeUITimezone();\n  $('#clock').attr('data-original-title', hostName).attr('data-placement', 'bottom').parent().show();\n  displayTime();\n  setInterval(displayTime, 1000);\n  $.ajaxSetup({\n    beforeSend(xhr, settings) {\n      if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n        xhr.setRequestHeader('X-CSRFToken', csrfToken);\n      }\n    }\n\n  });\n  $.fn.datetimepicker.defaults.format = 'YYYY-MM-DD HH:mm:ssZ';\n  $.fn.datetimepicker.defaults.sideBySide = true;\n  $('.datetimepicker').datetimepicker(); // Fix up filter fields from FAB adds to the page. This event is fired after\n  // the FAB registered one which adds the new control\n\n  $('#filter_form a.filter').click(() => {\n    $('.datetimepicker').datetimepicker();\n  }); // Global Tooltip selector\n\n  $('.js-tooltip').tooltip();\n});\n\nconst changeNavbarColor = () => {\n  if (window.scrollY >= 20) {\n    const element = document.getElementById('navbar');\n    element.classList.add('labelScroll'); // setValueScroll(true);\n  } else {\n    const element = document.getElementById('navbar');\n    element.classList.remove('labelScroll');\n  }\n};\n\nwindow.addEventListener('scroll', changeNavbarColor);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0FpcmZsb3cvLi9zdGF0aWMvanMvbWFpbi5qcz84NGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZ2xvYmFsICQsIG1vbWVudCwgQWlyZmxvdywgd2luZG93LCBsb2NhbFN0b3JhZ2UsIGRvY3VtZW50LCBob3N0TmFtZSwgY3NyZlRva2VuLCBDdXN0b21FdmVudCAqL1xuaW1wb3J0IHsgZGF0ZVRpbWVBdHRyRm9ybWF0LCBmb3JtYXRUaW1lem9uZSwgaXNvRGF0ZVRvVGltZUVsLCBzZXREaXNwbGF5ZWRUaW1lem9uZSwgVGltZXpvbmVFdmVudCB9IGZyb20gJy4vZGF0ZXRpbWVfdXRpbHMnO1xud2luZG93Lmlzb0RhdGVUb1RpbWVFbCA9IGlzb0RhdGVUb1RpbWVFbDtcbi8qXG4gV2UgcHVsbCBtb21lbnQgaW4gdmlhIGEgd2VicGFjayBlbnRyeXBvaW50IHJhdGhlciB0aGFuIGltcG9ydFxuIHNvIHRoYXQgd2UgZG9uJ3QgcHV0IGl0IGluIG1vcmUgdGhhbiBhIHNpbmdsZSAuanMgZmlsZS5cbiBUaGlzIFwiZXhwb3J0c1wiIGl0IHRvIGJlIGdsb2JhbGx5IGF2YWlsYWJsZS5cbiovXG5cbndpbmRvdy5tb21lbnQgPSBBaXJmbG93Lm1vbWVudDtcblxuZnVuY3Rpb24gZGlzcGxheVRpbWUoKSB7XG4gIGNvbnN0IG5vdyA9IG1vbWVudCgpO1xuICAkKCcjY2xvY2snKS5hdHRyKCdkYXRldGltZScsIG5vdy5mb3JtYXQoZGF0ZVRpbWVBdHRyRm9ybWF0KSkuaHRtbChgJHtub3cuZm9ybWF0KCdISDptbScpfSA8c3Ryb25nPiR7Zm9ybWF0VGltZXpvbmUobm93KX08L3N0cm9uZz5gKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlRGlzcGxheWVkVGltZXpvbmUodHopIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3NlbGVjdGVkLXRpbWV6b25lJywgdHopOyAvLyBkaXNwYXRjaCBhbiBldmVudCB0aGF0IFJlYWN0IGNhbiBsaXN0ZW4gZm9yXG5cbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoVGltZXpvbmVFdmVudCwge1xuICAgIGRldGFpbDogdHpcbiAgfSk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICBzZXREaXNwbGF5ZWRUaW1lem9uZSh0eik7XG4gIGRpc3BsYXlUaW1lKCk7XG4gICQoJ2JvZHknKS50cmlnZ2VyKHtcbiAgICB0eXBlOiAnYWlyZmxvdy50aW1lem9uZS1jaGFuZ2UnLFxuICAgIHRpbWV6b25lOiB0elxuICB9KTtcbn1cblxuY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0KSB7XG4gIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGVsLmlubmVySFRNTDtcbn1cbndpbmRvdy5lc2NhcGVIdG1sID0gZXNjYXBlSHRtbDtcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0U2Vjc1RvSHVtYW5SZWFkYWJsZShzZWNvbmRzKSB7XG4gIGNvbnN0IG9yaVNlY29uZHMgPSBzZWNvbmRzO1xuICBjb25zdCBmbG9hdGluZ1BhcnQgPSBvcmlTZWNvbmRzIC0gTWF0aC5mbG9vcihvcmlTZWNvbmRzKTtcbiAgc2Vjb25kcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyk7XG4gIGNvbnN0IHNlY29uZHNQZXJIb3VyID0gNjAgKiA2MDtcbiAgY29uc3Qgc2Vjb25kc1Blck1pbnV0ZSA9IDYwO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIHNlY29uZHNQZXJIb3VyKTtcbiAgc2Vjb25kcyAtPSBob3VycyAqIHNlY29uZHNQZXJIb3VyO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gc2Vjb25kc1Blck1pbnV0ZSk7XG4gIHNlY29uZHMgLT0gbWludXRlcyAqIHNlY29uZHNQZXJNaW51dGU7XG4gIGxldCByZWFkYWJsZUZvcm1hdCA9ICcnO1xuXG4gIGlmIChob3VycyA+IDApIHtcbiAgICByZWFkYWJsZUZvcm1hdCArPSBgJHtob3Vyc31Ib3VycyBgO1xuICB9XG5cbiAgaWYgKG1pbnV0ZXMgPiAwKSB7XG4gICAgcmVhZGFibGVGb3JtYXQgKz0gYCR7bWludXRlc31NaW4gYDtcbiAgfVxuXG4gIGlmIChzZWNvbmRzICsgZmxvYXRpbmdQYXJ0ID4gMCkge1xuICAgIGlmIChNYXRoLmZsb29yKG9yaVNlY29uZHMpID09PSBvcmlTZWNvbmRzKSB7XG4gICAgICByZWFkYWJsZUZvcm1hdCArPSBgJHtzZWNvbmRzfVNlY2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZHMgKz0gZmxvYXRpbmdQYXJ0O1xuICAgICAgcmVhZGFibGVGb3JtYXQgKz0gYCR7c2Vjb25kcy50b0ZpeGVkKDMpfVNlY2A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlRm9ybWF0O1xufVxud2luZG93LmNvbnZlcnRTZWNzVG9IdW1hblJlYWRhYmxlID0gY29udmVydFNlY3NUb0h1bWFuUmVhZGFibGU7XG5cbmZ1bmN0aW9uIHBvc3RBc0Zvcm0odXJsLCBwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IGZvcm0gPSAkKCc8Zm9ybT48L2Zvcm0+Jyk7XG4gIGZvcm0uYXR0cignbWV0aG9kJywgJ1BPU1QnKTtcbiAgZm9ybS5hdHRyKCdhY3Rpb24nLCB1cmwpO1xuICAkLmVhY2gocGFyYW1ldGVycyB8fCB7fSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBmaWVsZCA9ICQoJzxpbnB1dD48L2lucHV0PicpO1xuICAgIGZpZWxkLmF0dHIoJ3R5cGUnLCAnaGlkZGVuJyk7XG4gICAgZmllbGQuYXR0cignbmFtZScsIGtleSk7XG4gICAgZmllbGQuYXR0cigndmFsdWUnLCB2YWx1ZSk7XG4gICAgZm9ybS5hcHBlbmQoZmllbGQpO1xuICB9KTtcbiAgY29uc3QgZmllbGQgPSAkKCc8aW5wdXQ+PC9pbnB1dD4nKTtcbiAgZmllbGQuYXR0cigndHlwZScsICdoaWRkZW4nKTtcbiAgZmllbGQuYXR0cignbmFtZScsICdjc3JmX3Rva2VuJyk7XG4gIGZpZWxkLmF0dHIoJ3ZhbHVlJywgY3NyZlRva2VuKTtcbiAgZm9ybS5hcHBlbmQoZmllbGQpOyAvLyBUaGUgZm9ybSBuZWVkcyB0byBiZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IGluIG9yZGVyIGZvciB1cyB0byBiZSBhYmxlXG4gIC8vIHRvIHN1Ym1pdCBpdC5cblxuICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZChmb3JtKTtcbiAgZm9ybS5zdWJtaXQoKTtcbn1cblxud2luZG93LnBvc3RBc0Zvcm0gPSBwb3N0QXNGb3JtO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplVUlUaW1lem9uZSgpIHtcbiAgY29uc3QgbG9jYWwgPSBtb21lbnQudHouZ3Vlc3MoKTtcbiAgY29uc3Qgc2VsZWN0ZWRUeiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZWxlY3RlZC10aW1lem9uZScpO1xuICBjb25zdCBtYW51YWxUeiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaG9zZW4tdGltZXpvbmUnKTtcblxuICBmdW5jdGlvbiBzZXRNYW51YWxUaW1lem9uZSh0eikge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjaG9zZW4tdGltZXpvbmUnLCB0eik7XG5cbiAgICBpZiAodHogPT09IGxvY2FsICYmIHR6ID09PSBBaXJmbG93LnNlcnZlclRpbWV6b25lKSB7XG4gICAgICAkKCcjdGltZXpvbmUtbWFudWFsJykuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICQoJyN0aW1lem9uZS1tYW51YWwgYScpLmRhdGEoJ3RpbWV6b25lJywgdHopLnRleHQoZm9ybWF0VGltZXpvbmUodHopKTtcbiAgICAkKCcjdGltZXpvbmUtbWFudWFsJykuc2hvdygpO1xuICB9XG5cbiAgaWYgKG1hbnVhbFR6KSB7XG4gICAgc2V0TWFudWFsVGltZXpvbmUobWFudWFsVHopO1xuICB9XG5cbiAgY2hhbmdlRGlzcGxheWVkVGltZXpvbmUoc2VsZWN0ZWRUeiB8fCBBaXJmbG93LmRlZmF1bHRVSVRpbWV6b25lKTtcblxuICBpZiAoQWlyZmxvdy5zZXJ2ZXJUaW1lem9uZSAhPT0gJ1VUQycpIHtcbiAgICAkKCcjdGltZXpvbmUtc2VydmVyIGEnKS5odG1sKGAke2Zvcm1hdFRpbWV6b25lKEFpcmZsb3cuc2VydmVyVGltZXpvbmUpfSA8c3BhbiBjbGFzcz1cImxhYmVsIGxhYmVsLXByaW1hcnlcIj5TZXJ2ZXI8L3NwYW4+YCk7XG4gICAgJCgnI3RpbWV6b25lLXNlcnZlcicpLnNob3coKTtcbiAgfVxuXG4gIGlmIChBaXJmbG93LnNlcnZlclRpbWV6b25lICE9PSBsb2NhbCkge1xuICAgICQoJyN0aW1lem9uZS1sb2NhbCBhJykuYXR0cignZGF0YS10aW1lem9uZScsIGxvY2FsKS5odG1sKGAke2Zvcm1hdFRpbWV6b25lKGxvY2FsKX0gPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+TG9jYWw8L3NwYW4+YCk7XG4gIH0gZWxzZSB7XG4gICAgJCgnI3RpbWV6b25lLWxvY2FsJykuaGlkZSgpO1xuICB9XG5cbiAgJCgnYVtkYXRhLXRpbWV6b25lXScpLmNsaWNrKGV2dCA9PiB7XG4gICAgY2hhbmdlRGlzcGxheWVkVGltZXpvbmUoJChldnQuY3VycmVudFRhcmdldCkuZGF0YSgndGltZXpvbmUnKSk7XG4gIH0pO1xuICAkKCcjdGltZXpvbmUtb3RoZXInKS50eXBlYWhlYWQoe1xuICAgIHNvdXJjZTogJChtb21lbnQudHoubmFtZXMoKS5tYXAodHpOYW1lID0+IHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdHpOYW1lLnNwbGl0KCcvJywgMSlbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgbmFtZTogdHpOYW1lLnJlcGxhY2UoJ18nLCAnICcpLFxuICAgICAgICB0ek5hbWVcbiAgICAgIH07XG4gICAgfSkpLFxuICAgIHNob3dIaW50T25Gb2N1czogJ2FsbCcsXG4gICAgc2hvd0NhdGVnb3J5SGVhZGVyOiB0cnVlLFxuICAgIGl0ZW1zOiAnYWxsJyxcblxuICAgIGFmdGVyU2VsZWN0KGRhdGEpIHtcbiAgICAgIC8vIENsZWFyIGl0IGZvciBuZXh0IHRpbWUgd2Ugb3BlbiB0aGUgcG9wLXVwXG4gICAgICB0aGlzLiRlbGVtZW50LnZhbCgnJyk7XG4gICAgICBzZXRNYW51YWxUaW1lem9uZShkYXRhLnR6TmFtZSk7XG4gICAgICBjaGFuZ2VEaXNwbGF5ZWRUaW1lem9uZShkYXRhLnR6TmFtZSk7IC8vIFdlIG5lZWQgdG8gZGVsYXkgdGhlIGNsb3NlIGV2ZW50IHRvIG5vdCBiZSBpbiB0aGUgZm9ybSBoYW5kbGVyLFxuICAgICAgLy8gb3RoZXJ3aXNlIGJvb3RzdHJhcCBpZ25vcmVzIGl0LCB0aGlua2luZyBpdCdzIGNhdXNlZCBieSBpbnRlcmFjdGlvbiBvblxuICAgICAgLy8gdGhlIDxmb3JtPlxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7IC8vIEJ1ZyBpbiB0eXBlYWhlZCwgaXQgdGhpbmtzIGl0J3Mgc3RpbGwgc2hvd24hXG5cbiAgICAgICAgdGhpcy5zaG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIH0sIDEpO1xuICAgIH1cblxuICB9KTtcbn1cblxuJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xuICAvLyBjdXN0b20gcmVkaXJlY3QgaG9tZVxuICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignaG9tZScpID09PSAtMSkgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hdmJhcklkJykuaHJlZiA9ICcvJztcbiAgaW5pdGlhbGl6ZVVJVGltZXpvbmUoKTtcbiAgJCgnI2Nsb2NrJykuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsIGhvc3ROYW1lKS5hdHRyKCdkYXRhLXBsYWNlbWVudCcsICdib3R0b20nKS5wYXJlbnQoKS5zaG93KCk7XG4gIGRpc3BsYXlUaW1lKCk7XG4gIHNldEludGVydmFsKGRpc3BsYXlUaW1lLCAxMDAwKTtcbiAgJC5hamF4U2V0dXAoe1xuICAgIGJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykge1xuICAgICAgaWYgKCEvXihHRVR8SEVBRHxPUFRJT05TfFRSQUNFKSQvaS50ZXN0KHNldHRpbmdzLnR5cGUpICYmICF0aGlzLmNyb3NzRG9tYWluKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkZUb2tlbicsIGNzcmZUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuICAkLmZuLmRhdGV0aW1lcGlja2VyLmRlZmF1bHRzLmZvcm1hdCA9ICdZWVlZLU1NLUREIEhIOm1tOnNzWic7XG4gICQuZm4uZGF0ZXRpbWVwaWNrZXIuZGVmYXVsdHMuc2lkZUJ5U2lkZSA9IHRydWU7XG4gICQoJy5kYXRldGltZXBpY2tlcicpLmRhdGV0aW1lcGlja2VyKCk7IC8vIEZpeCB1cCBmaWx0ZXIgZmllbGRzIGZyb20gRkFCIGFkZHMgdG8gdGhlIHBhZ2UuIFRoaXMgZXZlbnQgaXMgZmlyZWQgYWZ0ZXJcbiAgLy8gdGhlIEZBQiByZWdpc3RlcmVkIG9uZSB3aGljaCBhZGRzIHRoZSBuZXcgY29udHJvbFxuXG4gICQoJyNmaWx0ZXJfZm9ybSBhLmZpbHRlcicpLmNsaWNrKCgpID0+IHtcbiAgICAkKCcuZGF0ZXRpbWVwaWNrZXInKS5kYXRldGltZXBpY2tlcigpO1xuICB9KTsgLy8gR2xvYmFsIFRvb2x0aXAgc2VsZWN0b3JcblxuICAkKCcuanMtdG9vbHRpcCcpLnRvb2x0aXAoKTtcbn0pO1xuXG5jb25zdCBjaGFuZ2VOYXZiYXJDb2xvciA9ICgpID0+IHtcbiAgaWYgKHdpbmRvdy5zY3JvbGxZID49IDIwKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXZiYXInKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhYmVsU2Nyb2xsJyk7IC8vIHNldFZhbHVlU2Nyb2xsKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2YmFyJyk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdsYWJlbFNjcm9sbCcpO1xuICB9XG59O1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgY2hhbmdlTmF2YmFyQ29sb3IpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./static/js/main.js\n");

/***/ }),

/***/ "./static/js/task_instances.js":
/*!*************************************!*\
  !*** ./static/js/task_instances.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tiTooltip),\n/* harmony export */   \"taskNoInstanceTooltip\": () => (/* binding */ taskNoInstanceTooltip)\n/* harmony export */ });\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./static/js/main.js\");\n/* harmony import */ var _datetime_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datetime_utils */ \"./static/js/datetime_utils.js\");\n/* harmony import */ var _dag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dag */ \"./static/js/dag.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./static/js/utils.js\");\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* global window, moment, convertSecsToHumanReadable */\n// We don't re-import moment again, otherwise webpack will include it twice in the bundle!\n\n\n\n\n\nfunction makeDateTimeHTML(start, end) {\n  // check task ended or not\n  const isEnded = end && end instanceof moment && end.isValid();\n  return `Started: ${start.format(_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.defaultFormat)}<br>Ended: ${isEnded ? end.format(_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.defaultFormat) : 'Not ended yet'}<br>`;\n}\n\nfunction generateTooltipDateTimes(startTime, endTime, dagTimezone) {\n  if (!startTime) {\n    return '<br><em>Not yet started</em>';\n  }\n\n  const tzFormat = 'z (Z)';\n  const localTZ = moment.defaultZone.name.toUpperCase();\n  const startDate = moment.utc(startTime);\n  const endDate = moment.utc(endTime);\n  const dagTz = dagTimezone.toUpperCase(); // Generate UTC Start and End Date\n\n  let tooltipHTML = '<br><strong>UTC:</strong><br>';\n  tooltipHTML += makeDateTimeHTML(startDate, endDate); // Generate User's Local Start and End Date, unless it's UTC\n\n  if (localTZ !== 'UTC') {\n    startDate.tz(localTZ);\n    tooltipHTML += `<br><strong>Local: ${startDate.format(tzFormat)}</strong><br>`;\n    const localEndDate = endDate && endDate instanceof moment ? endDate.tz(localTZ) : endDate;\n    tooltipHTML += makeDateTimeHTML(startDate, localEndDate);\n  } // Generate DAG's Start and End Date\n\n\n  if (dagTz !== 'UTC' && dagTz !== localTZ) {\n    startDate.tz(dagTz);\n    tooltipHTML += `<br><strong>DAG's TZ: ${startDate.format(tzFormat)}</strong><br>`;\n    const dagTZEndDate = endDate && endDate instanceof moment ? endDate.tz(dagTz) : endDate;\n    tooltipHTML += makeDateTimeHTML(startDate, dagTZEndDate);\n  }\n\n  return tooltipHTML;\n}\n\nfunction tiTooltip(ti, {\n  includeTryNumber = false\n} = {}) {\n  let tt = '';\n\n  if (ti.state !== undefined) {\n    tt += `<strong>Status:</strong> ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.state)}<br><br>`;\n  }\n\n  if (ti.mapped_states) {\n    const numMap = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.finalStatesMap)();\n    ti.mapped_states.forEach(s => {\n      const stateKey = s || 'no_status';\n      if (numMap.has(stateKey)) numMap.set(stateKey, numMap.get(stateKey) + 1);\n    });\n    tt += `<strong>${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.mapped_states.length)} ${ti.mapped_states.length === 1 ? 'Task' : 'Tasks'} Mapped</strong><br />`;\n    numMap.forEach((key, val) => {\n      if (key > 0) {\n        tt += `<span style=\"margin-left: 15px\">${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(val)}: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(key)}</span><br />`;\n      }\n    });\n    tt += '<br />';\n  }\n\n  if (ti.task_id !== undefined) {\n    tt += `Task_id: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.task_id)}<br>`;\n  }\n\n  tt += `Run: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(ti.execution_date)}<br>`;\n\n  if (ti.run_id !== undefined) {\n    tt += `Run Id: <nobr>${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.run_id)}</nobr><br>`;\n  } // Show mapped index for specific child instance, but not for a summary instance\n\n\n  if (ti.map_index >= 0 && !ti.mapped_states) {\n    tt += `Map Index: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.map_index)}<br>`;\n  }\n\n  if (ti.operator !== undefined) {\n    tt += `Operator: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.operator)}<br>`;\n  } // Calculate duration on the fly if task instance is still running\n\n\n  if (ti.state === 'running') {\n    const startDate = ti.start_date instanceof moment ? ti.start_date : moment(ti.start_date);\n    ti.duration = moment().diff(startDate, 'second');\n  } else if (!ti.duration && ti.end_date) {\n    const startDate = ti.start_date instanceof moment ? ti.start_date : moment(ti.start_date);\n    const endDate = ti.end_date instanceof moment ? ti.end_date : moment(ti.end_date);\n    ti.duration = moment(endDate).diff(startDate, 'second');\n  }\n\n  tt += `Duration: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(convertSecsToHumanReadable(ti.duration))}<br>`;\n  const intervalStart = ti.data_interval_start;\n  const intervalEnd = ti.data_interval_end;\n\n  if (intervalStart && intervalEnd) {\n    tt += '<br><strong>Data Interval:</strong><br>';\n    tt += `Start: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(intervalStart)}<br>`;\n    tt += `End: ${(0,_datetime_utils__WEBPACK_IMPORTED_MODULE_1__.formatDateTime)(intervalEnd)}<br>`;\n  }\n\n  if (includeTryNumber) {\n    tt += `Try Number: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(ti.try_number)}<br>`;\n  } // dagTZ has been defined in dag.html\n\n\n  tt += generateTooltipDateTimes(ti.start_date, ti.end_date, _dag__WEBPACK_IMPORTED_MODULE_2__.dagTZ || 'UTC');\n  return tt;\n}\nfunction taskNoInstanceTooltip(taskId, task) {\n  let tt = '';\n\n  if (taskId) {\n    tt += `Task_id: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(taskId)}<br>`;\n  }\n\n  if (task.task_type !== undefined) {\n    tt += `Operator: ${(0,_main__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(task.task_type)}<br>`;\n  }\n\n  tt += '<br><em>DAG has yet to run.</em>';\n  return tt;\n}\nwindow.tiTooltip = tiTooltip;\nwindow.taskNoInstanceTooltip = taskNoInstanceTooltip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvdGFza19pbnN0YW5jZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BaXJmbG93Ly4vc3RhdGljL2pzL3Rhc2tfaW5zdGFuY2VzLmpzPzRjZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBnbG9iYWwgd2luZG93LCBtb21lbnQsIGNvbnZlcnRTZWNzVG9IdW1hblJlYWRhYmxlICovXG4vLyBXZSBkb24ndCByZS1pbXBvcnQgbW9tZW50IGFnYWluLCBvdGhlcndpc2Ugd2VicGFjayB3aWxsIGluY2x1ZGUgaXQgdHdpY2UgaW4gdGhlIGJ1bmRsZSFcbmltcG9ydCB7IGVzY2FwZUh0bWwgfSBmcm9tICcuL21haW4nO1xuaW1wb3J0IHsgZGVmYXVsdEZvcm1hdCwgZm9ybWF0RGF0ZVRpbWUgfSBmcm9tICcuL2RhdGV0aW1lX3V0aWxzJztcbmltcG9ydCB7IGRhZ1RaIH0gZnJvbSAnLi9kYWcnO1xuaW1wb3J0IHsgZmluYWxTdGF0ZXNNYXAgfSBmcm9tICcuL3V0aWxzJztcblxuZnVuY3Rpb24gbWFrZURhdGVUaW1lSFRNTChzdGFydCwgZW5kKSB7XG4gIC8vIGNoZWNrIHRhc2sgZW5kZWQgb3Igbm90XG4gIGNvbnN0IGlzRW5kZWQgPSBlbmQgJiYgZW5kIGluc3RhbmNlb2YgbW9tZW50ICYmIGVuZC5pc1ZhbGlkKCk7XG4gIHJldHVybiBgU3RhcnRlZDogJHtzdGFydC5mb3JtYXQoZGVmYXVsdEZvcm1hdCl9PGJyPkVuZGVkOiAke2lzRW5kZWQgPyBlbmQuZm9ybWF0KGRlZmF1bHRGb3JtYXQpIDogJ05vdCBlbmRlZCB5ZXQnfTxicj5gO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRvb2x0aXBEYXRlVGltZXMoc3RhcnRUaW1lLCBlbmRUaW1lLCBkYWdUaW1lem9uZSkge1xuICBpZiAoIXN0YXJ0VGltZSkge1xuICAgIHJldHVybiAnPGJyPjxlbT5Ob3QgeWV0IHN0YXJ0ZWQ8L2VtPic7XG4gIH1cblxuICBjb25zdCB0ekZvcm1hdCA9ICd6IChaKSc7XG4gIGNvbnN0IGxvY2FsVFogPSBtb21lbnQuZGVmYXVsdFpvbmUubmFtZS50b1VwcGVyQ2FzZSgpO1xuICBjb25zdCBzdGFydERhdGUgPSBtb21lbnQudXRjKHN0YXJ0VGltZSk7XG4gIGNvbnN0IGVuZERhdGUgPSBtb21lbnQudXRjKGVuZFRpbWUpO1xuICBjb25zdCBkYWdUeiA9IGRhZ1RpbWV6b25lLnRvVXBwZXJDYXNlKCk7IC8vIEdlbmVyYXRlIFVUQyBTdGFydCBhbmQgRW5kIERhdGVcblxuICBsZXQgdG9vbHRpcEhUTUwgPSAnPGJyPjxzdHJvbmc+VVRDOjwvc3Ryb25nPjxicj4nO1xuICB0b29sdGlwSFRNTCArPSBtYWtlRGF0ZVRpbWVIVE1MKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7IC8vIEdlbmVyYXRlIFVzZXIncyBMb2NhbCBTdGFydCBhbmQgRW5kIERhdGUsIHVubGVzcyBpdCdzIFVUQ1xuXG4gIGlmIChsb2NhbFRaICE9PSAnVVRDJykge1xuICAgIHN0YXJ0RGF0ZS50eihsb2NhbFRaKTtcbiAgICB0b29sdGlwSFRNTCArPSBgPGJyPjxzdHJvbmc+TG9jYWw6ICR7c3RhcnREYXRlLmZvcm1hdCh0ekZvcm1hdCl9PC9zdHJvbmc+PGJyPmA7XG4gICAgY29uc3QgbG9jYWxFbmREYXRlID0gZW5kRGF0ZSAmJiBlbmREYXRlIGluc3RhbmNlb2YgbW9tZW50ID8gZW5kRGF0ZS50eihsb2NhbFRaKSA6IGVuZERhdGU7XG4gICAgdG9vbHRpcEhUTUwgKz0gbWFrZURhdGVUaW1lSFRNTChzdGFydERhdGUsIGxvY2FsRW5kRGF0ZSk7XG4gIH0gLy8gR2VuZXJhdGUgREFHJ3MgU3RhcnQgYW5kIEVuZCBEYXRlXG5cblxuICBpZiAoZGFnVHogIT09ICdVVEMnICYmIGRhZ1R6ICE9PSBsb2NhbFRaKSB7XG4gICAgc3RhcnREYXRlLnR6KGRhZ1R6KTtcbiAgICB0b29sdGlwSFRNTCArPSBgPGJyPjxzdHJvbmc+REFHJ3MgVFo6ICR7c3RhcnREYXRlLmZvcm1hdCh0ekZvcm1hdCl9PC9zdHJvbmc+PGJyPmA7XG4gICAgY29uc3QgZGFnVFpFbmREYXRlID0gZW5kRGF0ZSAmJiBlbmREYXRlIGluc3RhbmNlb2YgbW9tZW50ID8gZW5kRGF0ZS50eihkYWdUeikgOiBlbmREYXRlO1xuICAgIHRvb2x0aXBIVE1MICs9IG1ha2VEYXRlVGltZUhUTUwoc3RhcnREYXRlLCBkYWdUWkVuZERhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHRvb2x0aXBIVE1MO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aVRvb2x0aXAodGksIHtcbiAgaW5jbHVkZVRyeU51bWJlciA9IGZhbHNlXG59ID0ge30pIHtcbiAgbGV0IHR0ID0gJyc7XG5cbiAgaWYgKHRpLnN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0dCArPSBgPHN0cm9uZz5TdGF0dXM6PC9zdHJvbmc+ICR7ZXNjYXBlSHRtbCh0aS5zdGF0ZSl9PGJyPjxicj5gO1xuICB9XG5cbiAgaWYgKHRpLm1hcHBlZF9zdGF0ZXMpIHtcbiAgICBjb25zdCBudW1NYXAgPSBmaW5hbFN0YXRlc01hcCgpO1xuICAgIHRpLm1hcHBlZF9zdGF0ZXMuZm9yRWFjaChzID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlS2V5ID0gcyB8fCAnbm9fc3RhdHVzJztcbiAgICAgIGlmIChudW1NYXAuaGFzKHN0YXRlS2V5KSkgbnVtTWFwLnNldChzdGF0ZUtleSwgbnVtTWFwLmdldChzdGF0ZUtleSkgKyAxKTtcbiAgICB9KTtcbiAgICB0dCArPSBgPHN0cm9uZz4ke2VzY2FwZUh0bWwodGkubWFwcGVkX3N0YXRlcy5sZW5ndGgpfSAke3RpLm1hcHBlZF9zdGF0ZXMubGVuZ3RoID09PSAxID8gJ1Rhc2snIDogJ1Rhc2tzJ30gTWFwcGVkPC9zdHJvbmc+PGJyIC8+YDtcbiAgICBudW1NYXAuZm9yRWFjaCgoa2V5LCB2YWwpID0+IHtcbiAgICAgIGlmIChrZXkgPiAwKSB7XG4gICAgICAgIHR0ICs9IGA8c3BhbiBzdHlsZT1cIm1hcmdpbi1sZWZ0OiAxNXB4XCI+JHtlc2NhcGVIdG1sKHZhbCl9OiAke2VzY2FwZUh0bWwoa2V5KX08L3NwYW4+PGJyIC8+YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0dCArPSAnPGJyIC8+JztcbiAgfVxuXG4gIGlmICh0aS50YXNrX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0dCArPSBgVGFza19pZDogJHtlc2NhcGVIdG1sKHRpLnRhc2tfaWQpfTxicj5gO1xuICB9XG5cbiAgdHQgKz0gYFJ1bjogJHtmb3JtYXREYXRlVGltZSh0aS5leGVjdXRpb25fZGF0ZSl9PGJyPmA7XG5cbiAgaWYgKHRpLnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHQgKz0gYFJ1biBJZDogPG5vYnI+JHtlc2NhcGVIdG1sKHRpLnJ1bl9pZCl9PC9ub2JyPjxicj5gO1xuICB9IC8vIFNob3cgbWFwcGVkIGluZGV4IGZvciBzcGVjaWZpYyBjaGlsZCBpbnN0YW5jZSwgYnV0IG5vdCBmb3IgYSBzdW1tYXJ5IGluc3RhbmNlXG5cblxuICBpZiAodGkubWFwX2luZGV4ID49IDAgJiYgIXRpLm1hcHBlZF9zdGF0ZXMpIHtcbiAgICB0dCArPSBgTWFwIEluZGV4OiAke2VzY2FwZUh0bWwodGkubWFwX2luZGV4KX08YnI+YDtcbiAgfVxuXG4gIGlmICh0aS5vcGVyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHQgKz0gYE9wZXJhdG9yOiAke2VzY2FwZUh0bWwodGkub3BlcmF0b3IpfTxicj5gO1xuICB9IC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBvbiB0aGUgZmx5IGlmIHRhc2sgaW5zdGFuY2UgaXMgc3RpbGwgcnVubmluZ1xuXG5cbiAgaWYgKHRpLnN0YXRlID09PSAncnVubmluZycpIHtcbiAgICBjb25zdCBzdGFydERhdGUgPSB0aS5zdGFydF9kYXRlIGluc3RhbmNlb2YgbW9tZW50ID8gdGkuc3RhcnRfZGF0ZSA6IG1vbWVudCh0aS5zdGFydF9kYXRlKTtcbiAgICB0aS5kdXJhdGlvbiA9IG1vbWVudCgpLmRpZmYoc3RhcnREYXRlLCAnc2Vjb25kJyk7XG4gIH0gZWxzZSBpZiAoIXRpLmR1cmF0aW9uICYmIHRpLmVuZF9kYXRlKSB7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gdGkuc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIG1vbWVudCA/IHRpLnN0YXJ0X2RhdGUgOiBtb21lbnQodGkuc3RhcnRfZGF0ZSk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IHRpLmVuZF9kYXRlIGluc3RhbmNlb2YgbW9tZW50ID8gdGkuZW5kX2RhdGUgOiBtb21lbnQodGkuZW5kX2RhdGUpO1xuICAgIHRpLmR1cmF0aW9uID0gbW9tZW50KGVuZERhdGUpLmRpZmYoc3RhcnREYXRlLCAnc2Vjb25kJyk7XG4gIH1cblxuICB0dCArPSBgRHVyYXRpb246ICR7ZXNjYXBlSHRtbChjb252ZXJ0U2Vjc1RvSHVtYW5SZWFkYWJsZSh0aS5kdXJhdGlvbikpfTxicj5gO1xuICBjb25zdCBpbnRlcnZhbFN0YXJ0ID0gdGkuZGF0YV9pbnRlcnZhbF9zdGFydDtcbiAgY29uc3QgaW50ZXJ2YWxFbmQgPSB0aS5kYXRhX2ludGVydmFsX2VuZDtcblxuICBpZiAoaW50ZXJ2YWxTdGFydCAmJiBpbnRlcnZhbEVuZCkge1xuICAgIHR0ICs9ICc8YnI+PHN0cm9uZz5EYXRhIEludGVydmFsOjwvc3Ryb25nPjxicj4nO1xuICAgIHR0ICs9IGBTdGFydDogJHtmb3JtYXREYXRlVGltZShpbnRlcnZhbFN0YXJ0KX08YnI+YDtcbiAgICB0dCArPSBgRW5kOiAke2Zvcm1hdERhdGVUaW1lKGludGVydmFsRW5kKX08YnI+YDtcbiAgfVxuXG4gIGlmIChpbmNsdWRlVHJ5TnVtYmVyKSB7XG4gICAgdHQgKz0gYFRyeSBOdW1iZXI6ICR7ZXNjYXBlSHRtbCh0aS50cnlfbnVtYmVyKX08YnI+YDtcbiAgfSAvLyBkYWdUWiBoYXMgYmVlbiBkZWZpbmVkIGluIGRhZy5odG1sXG5cblxuICB0dCArPSBnZW5lcmF0ZVRvb2x0aXBEYXRlVGltZXModGkuc3RhcnRfZGF0ZSwgdGkuZW5kX2RhdGUsIGRhZ1RaIHx8ICdVVEMnKTtcbiAgcmV0dXJuIHR0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tOb0luc3RhbmNlVG9vbHRpcCh0YXNrSWQsIHRhc2spIHtcbiAgbGV0IHR0ID0gJyc7XG5cbiAgaWYgKHRhc2tJZCkge1xuICAgIHR0ICs9IGBUYXNrX2lkOiAke2VzY2FwZUh0bWwodGFza0lkKX08YnI+YDtcbiAgfVxuXG4gIGlmICh0YXNrLnRhc2tfdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHQgKz0gYE9wZXJhdG9yOiAke2VzY2FwZUh0bWwodGFzay50YXNrX3R5cGUpfTxicj5gO1xuICB9XG5cbiAgdHQgKz0gJzxicj48ZW0+REFHIGhhcyB5ZXQgdG8gcnVuLjwvZW0+JztcbiAgcmV0dXJuIHR0O1xufVxud2luZG93LnRpVG9vbHRpcCA9IHRpVG9vbHRpcDtcbndpbmRvdy50YXNrTm9JbnN0YW5jZVRvb2x0aXAgPSB0YXNrTm9JbnN0YW5jZVRvb2x0aXA7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./static/js/task_instances.js\n");

/***/ }),

/***/ "./static/js/utils.js":
/*!****************************!*\
  !*** ./static/js/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appendSearchParams\": () => (/* binding */ appendSearchParams),\n/* harmony export */   \"finalStatesMap\": () => (/* binding */ finalStatesMap),\n/* harmony export */   \"getMetaValue\": () => (/* binding */ getMetaValue)\n/* harmony export */ });\n/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* global document */\nfunction getMetaValue(name) {\n  const elem = document.querySelector(`meta[name=\"${name}\"]`);\n\n  if (!elem) {\n    return null;\n  }\n\n  return elem.getAttribute('content');\n}\nconst finalStatesMap = () => new Map([['success', 0], ['failed', 0], ['upstream_failed', 0], ['up_for_retry', 0], ['up_for_reschedule', 0], ['running', 0], ['deferred', 0], ['sensing', 0], ['queued', 0], ['scheduled', 0], ['skipped', 0], ['no_status', 0]]);\nconst appendSearchParams = (url, params) => {\n  const separator = url.includes('?') ? '&' : '?';\n  return `${url}${separator}${params}`;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvanMvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BaXJmbG93Ly4vc3RhdGljL2pzL3V0aWxzLmpzP2Q2OGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRhVmFsdWUobmFtZSkge1xuICBjb25zdCBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbWV0YVtuYW1lPVwiJHtuYW1lfVwiXWApO1xuXG4gIGlmICghZWxlbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG59XG5leHBvcnQgY29uc3QgZmluYWxTdGF0ZXNNYXAgPSAoKSA9PiBuZXcgTWFwKFtbJ3N1Y2Nlc3MnLCAwXSwgWydmYWlsZWQnLCAwXSwgWyd1cHN0cmVhbV9mYWlsZWQnLCAwXSwgWyd1cF9mb3JfcmV0cnknLCAwXSwgWyd1cF9mb3JfcmVzY2hlZHVsZScsIDBdLCBbJ3J1bm5pbmcnLCAwXSwgWydkZWZlcnJlZCcsIDBdLCBbJ3NlbnNpbmcnLCAwXSwgWydxdWV1ZWQnLCAwXSwgWydzY2hlZHVsZWQnLCAwXSwgWydza2lwcGVkJywgMF0sIFsnbm9fc3RhdHVzJywgMF1dKTtcbmV4cG9ydCBjb25zdCBhcHBlbmRTZWFyY2hQYXJhbXMgPSAodXJsLCBwYXJhbXMpID0+IHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gdXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gIHJldHVybiBgJHt1cmx9JHtzZXBhcmF0b3J9JHtwYXJhbXN9YDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./static/js/utils.js\n");

/***/ }),

/***/ "./static/css/graph.css":
/*!******************************!*\
  !*** ./static/css/graph.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0aWMvY3NzL2dyYXBoLmNzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BaXJmbG93Ly4vc3RhdGljL2Nzcy9ncmFwaC5jc3M/ZDM4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./static/css/graph.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./static/css/graph.css");
/******/ 	var __webpack_exports__ = __webpack_require__("./static/js/graph.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});